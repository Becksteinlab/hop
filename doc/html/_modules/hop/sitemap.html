

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>hop.sitemap &mdash; Hop 0.3.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.3.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Hop 0.3.3 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Hop 0.3.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for hop.sitemap</h1><div class="highlight"><pre>
<span class="c"># Hop --- a framework to analyze solvation dynamics from MD simulations</span>
<span class="c"># Copyright (c) 2007-2010 Oliver Beckstein &lt;orbeckst@gmail.com&gt;</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Histogram positions of particles from a MD trajectory on a</span>
<span class="sd">grid. Calculate the density, change units (both of the grid and of the</span>
<span class="sd">density), save the density, export into 3D visualization formats,</span>
<span class="sd">manipulate the density as a numpy array.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">hop.constants</span>
<span class="kn">from</span> <span class="nn">hop.constants</span> <span class="kn">import</span> <span class="n">SITELABEL</span>
<span class="kn">import</span> <span class="nn">hop.utilities</span>
<span class="kn">from</span> <span class="nn">hop.utilities</span> <span class="kn">import</span> <span class="n">msg</span><span class="p">,</span><span class="n">set_verbosity</span><span class="p">,</span><span class="n">get_verbosity</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> \
     <span class="n">DefaultDict</span><span class="p">,</span> <span class="n">fixedwidth_bins</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">asiterable</span>
<span class="kn">import</span> <span class="nn">numpy</span>  <span class="c"># need v &gt;= 1.0</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">os.path</span><span class="o">,</span><span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">cPickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">gridData</span> <span class="kn">import</span> <span class="n">OpenDX</span>    <span class="c"># http://github.com/orbeckst/GridDataFormats </span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">NX</span>          <span class="c"># https://networkx.lanl.gov/</span>

<span class="c"># set() for older versions of python (&lt;2.4)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sets</span> <span class="kn">import</span> <span class="n">Set</span> <span class="k">as</span> <span class="nb">set</span>


<div class="viewcode-block" id="Grid"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid">[docs]</a><span class="k">class</span> <span class="nc">Grid</span><span class="p">(</span><span class="n">hop</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">Saveable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to manage a multidimensional grid object.</span>

<span class="sd">    The grid (Grid.grid) can be manipulated as a standard numpy</span>
<span class="sd">    array. Changes can be saved to a file using the save() method. The</span>
<span class="sd">    grid can be restored using the load() method or by supplying the</span>
<span class="sd">    filename to the constructor.</span>

<span class="sd">    The attribute Grid.metadata holds a user-defined dictionary that</span>
<span class="sd">    can be used to annotate the data. It is saved with save().</span>

<span class="sd">    The export(format=&#39;dx&#39;) method always exports a 3D object, the</span>
<span class="sd">    rest should work for an array of any dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_saved_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="s">&#39;edges&#39;</span><span class="p">,</span><span class="s">&#39;P&#39;</span><span class="p">,</span><span class="s">&#39;unit&#39;</span><span class="p">,</span><span class="s">&#39;metadata&#39;</span><span class="p">]</span>

    <span class="n">parameters_default</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;isDensity&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">}</span>
    <span class="n">unit_default</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;length&#39;</span><span class="p">:</span><span class="s">&#39;Angstrom&#39;</span><span class="p">,</span><span class="s">&#39;density&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dxfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">parameters</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Grid object from data.</span>

<span class="sd">        From a numpy.histogramdd():</span>
<span class="sd">          g = Grid(grid,edges)</span>
<span class="sd">        From files (created with Grid.save(&lt;filename&gt;):</span>
<span class="sd">          g = Grid(filename=&lt;filename&gt;)</span>
<span class="sd">        From a dx file:</span>
<span class="sd">          g = Grid(dxfile=&lt;dxfile&gt;)</span>

<span class="sd">        Arguments:</span>
<span class="sd">        </span>
<span class="sd">        grid       histogram or density and ...</span>
<span class="sd">        edges      list of arrays, the lower and upper bin edges along the axes</span>
<span class="sd">                   (both are output by numpy.histogramdd())</span>
<span class="sd">        filename   file name of a pickled Grid instance (created with</span>
<span class="sd">                   Grid.save(filename))</span>
<span class="sd">        dxfile     OpenDX file</span>
<span class="sd">        parameters dictionary of class parameters; saved with save()</span>
<span class="sd">                   isDensity  False: grid is a histogram with counts,</span>
<span class="sd">                              True: a density.</span>
<span class="sd">                              Applying Grid.make_density() sets it to True.</span>
<span class="sd">        unit       dict(length=&#39;Angstrom&#39;, density=None) </span>
<span class="sd">                   length:  physical unit of grid edges (Angstrom or nm)</span>
<span class="sd">                   density: unit of the density if isDensity == True or None</span>
<span class="sd">        metadata   a user defined dictionary of arbitrary values</span>
<span class="sd">                   associated with the density; the class does not touch</span>
<span class="sd">                   metadata[] but stores it with save()</span>

<span class="sd">        Returns:</span>
<span class="sd">        g          a Grid object</span>

<span class="sd">        If the input histogram consists of counts per cell then the</span>
<span class="sd">        make_density() method converts the grid to a physical</span>
<span class="sd">        density. For a probability density, divide it by grid.sum(0 or</span>
<span class="sd">        use normed=True right away in histogramdd().</span>

<span class="sd">        If grid, edges, AND filename are given then the</span>
<span class="sd">        extension-stripped filename is stored as the default filename.</span>

<span class="sd">        NOTE:</span>
<span class="sd">        </span>
<span class="sd">        * It is suggested to construct the Grid object from a</span>
<span class="sd">          histogram, to supply the appropriate length unit, and to use</span>
<span class="sd">          make_density() to obtain a density. This ensures that the</span>
<span class="sd">          length- and the density unit correspond to each other.</span>

<span class="sd">        TODO:</span>
<span class="sd">        * arg list is still messy</span>
<span class="sd">        * probability density not supported as a unit        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters_default</span><span class="p">,</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_default</span><span class="p">,</span><span class="n">unit</span><span class="p">)</span>        
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">({},</span><span class="n">metadata</span><span class="p">)</span>
        
        <span class="c"># First set attributes that may be overriden by reading from a file</span>
        <span class="c"># using load().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dxfile</span> <span class="o">=</span> <span class="n">dxfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">parameters</span>    <span class="c"># isDensity: set by make_density()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>                 <span class="c"># use this to record arbitrary data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>   <span class="c"># unit must be dict --- check here?</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">grid</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">edges</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="k">elif</span> <span class="n">filename</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Grid</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>  <span class="c"># uses self.load(filename)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>          <span class="c"># crucial because not all attributes are pickled!</span>
            <span class="k">return</span>                  <span class="c"># get out right away to keep it clean</span>
        <span class="k">elif</span> <span class="n">dxfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">importdx</span><span class="p">(</span><span class="n">dxfile</span><span class="p">)</span>   <span class="c"># calls __init__() again with data</span>
            <span class="k">return</span>                  <span class="c"># get out right away to keep it clean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no input data---eg (grid,edges) or filename---for grid given&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute/update all derived data</span>

<span class="sd">        Can be called without harm (idem-potent); needed separately</span>
<span class="sd">        when the units are changed.</span>

<span class="sd">        origin  is the center of the cell with index 0,0,0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span>

        <span class="c"># sanity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;For a density, unit[&#39;density&#39;] must be set.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that all bindings {unit_type : value, ...} in the dict u are valid</span>
<span class="sd">        and set the object&#39;s unit attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># all this unit crap should be a class...</span>
        <span class="c"># Also see comments near definition of hop.constants.conversion_factor[].</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">unit_type</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>   <span class="c"># check here, too iffy to use dictionary[None]=None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="n">unit_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">conversion_factor</span><span class="p">[</span><span class="n">unit_type</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="n">unit_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unit &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">+</span>\
                                     <span class="s">&#39; of type &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">unit_type</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; is not recognized.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;&quot;unit&quot; must be a dictionary with keys &quot;length&quot; and &quot;density&quot;.&#39;</span><span class="p">)</span>
        <span class="c"># need at least length and density (can be None)</span>
        <span class="k">if</span> <span class="s">&#39;length&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;&quot;unit&quot; must contain a unit for &quot;length&quot;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;density&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="Grid.make_density"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.make_density">[docs]</a>    <span class="k">def</span> <span class="nf">make_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the grid (a histogram, counts in a cell) to a density (counts/volume).</span>

<span class="sd">        make_density()</span>

<span class="sd">        Note: (1) This changes the grid irrevocably.</span>
<span class="sd">              (2) For a probability density, manually divide by grid.sum().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Make it a density by dividing by the volume of each grid cell</span>
        <span class="c"># (from numpy.histogramdd, which is for general n-D grids)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Grid is already a density.&quot;</span><span class="p">)</span>
        
        <span class="n">dedges</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">/=</span> <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span>
        </div>
<div class="viewcode-block" id="Grid.convert_length"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.convert_length">[docs]</a>    <span class="k">def</span> <span class="nf">convert_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert Grid object to the new unit:</span>
<span class="sd">        Grid.convert_length(&lt;unit&gt;)</span>

<span class="sd">        unit       Angstrom, nm</span>

<span class="sd">        This changes the edges but will not change the density; it is</span>
<span class="sd">        the user&#39;s responsibility to supply the appropriate unit if</span>
<span class="sd">        the Grid object is constructed from a density. It is suggested</span>
<span class="sd">        to start from a histogram and a length unit and use</span>
<span class="sd">        make_density().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="n">cvnfact</span> <span class="o">=</span> <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s">&#39;length&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">],</span><span class="n">unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">cvnfact</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>        <span class="c"># needed to recalculate midpoints and origin</span>
</div>
<div class="viewcode-block" id="Grid.convert_density"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.convert_density">[docs]</a>    <span class="k">def</span> <span class="nf">convert_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the density to the physical units given by unit</span>

<span class="sd">        Grid.convert_to(&lt;unit&gt;)</span>

<span class="sd">        &lt;unit&gt; can be one of the following:</span>

<span class="sd">        Angstrom     particles/A**3</span>
<span class="sd">        nm           particles/nm**3</span>
<span class="sd">        SPC          density of SPC water at standard conditions</span>
<span class="sd">        TIP3P        ... see __water__[&#39;TIP3P&#39;]</span>
<span class="sd">        TIP4P        ... ...</span>
<span class="sd">        water        density of real water at standard conditions (0.997 g/cm**3)</span>
<span class="sd">        Molar        mol/l</span>

<span class="sd">        Note: (1) This only works if the initial length unit is provided.</span>
<span class="sd">              (2) Conversions always go back to unity so there can be rounding</span>
<span class="sd">                  and floating point artifacts for multiple conversions.</span>

<span class="sd">        There may be some undesirable cross-interactions with convert_length...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;The grid is not a density so converty_density(0 makes no sense.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">*=</span> <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s">&#39;density&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">],</span><span class="n">unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span>
      </div>
<div class="viewcode-block" id="Grid.centers"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.centers">[docs]</a>    <span class="k">def</span> <span class="nf">centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the coordinates of the centers of all grid cells as an iterator.&quot;&quot;&quot;</span>
        <span class="c"># crappy</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="c"># TODO: CHECK that this delta*(i,j,k) is really correct, even for non-diagonal delta</span>
            <span class="c"># NOTE: origin is center of (0,0,0) (and already has index offset by 0.5)</span>
            <span class="k">yield</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>

              </div>
<div class="viewcode-block" id="Grid.importdx"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.importdx">[docs]</a>    <span class="k">def</span> <span class="nf">importdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dxfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes Grid from a OpenDX file.&quot;&quot;&quot;</span>
        
        <span class="n">dx</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dx</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">dxfile</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">dx</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                      <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span><span class="n">dxfile</span><span class="o">=</span><span class="n">dxfile</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Grid.export"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Grid.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dx&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;export density to file using the given format; use &#39;dx&#39; for visualization.</span>

<span class="sd">        export(filename=&lt;filename&gt;,format=&lt;format&gt;)</span>

<span class="sd">        The &lt;filename&gt; can be omitted if a default file name already</span>
<span class="sd">        exists for the object (e.g. if it was loaded from a file or it</span>
<span class="sd">        was saved before.) Do not supply the filename extension. The</span>
<span class="sd">        correct one will be added by the method.</span>

<span class="sd">        The default format for export() is &#39;dx&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Only implemented formats:</span>

<span class="sd">        dx        OpenDX (WRITE ONLY)</span>
<span class="sd">        python    pickle (use Grid.load(filename) to restore); Grid.save()</span>
<span class="sd">                  is simpler than export(format=&#39;python&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&quot;dx&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_export_dx</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&quot;python&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Exporting to format &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="o">+</span>\
                                      <span class="s">&quot; is not implemented.&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_export_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export the density grid to an OpenDX file. The file format</span>
<span class="sd">        is the simplest regular grid array and it is also understood</span>
<span class="sd">        by VMD&#39;s DX reader.</span>

<span class="sd">        For the file format see</span>
<span class="sd">        http://opendx.sdsc.edu/docs/html/pages/usrgu068.htm#HDREDF</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;.dx&#39;</span>

        <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s">&#39;OpenDX density file written by&#39;</span><span class="p">,</span>
            <span class="s">&#39;$Id$&#39;</span><span class="p">,</span>
            <span class="s">&#39;File format: http://opendx.sdsc.edu/docs/html/pages/usrgu068.htm#HDREDF&#39;</span><span class="p">,</span>
            <span class="s">&#39;Data are embedded in the header and tied to the grid positions.&#39;</span><span class="p">,</span>
            <span class="s">&#39;Unit of   length    is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="p">,</span>
            <span class="s">&#39;Unit of   density   is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;-based.&#39;</span><span class="p">,</span>
            <span class="s">&#39;Data is written in C array order: In grid[x,y,z] the axis z is fastest&#39;</span><span class="p">,</span>
            <span class="s">&#39;varying, then y, then finally x, i.e. z is the innermost loop.&#39;</span><span class="p">]</span>

        <span class="c"># write metadata in comments section</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Meta data stored with the python Grid object:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;   &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;(Note: the VMD dx-reader chokes on comments below this line)&#39;</span><span class="p">)</span>

        <span class="n">components</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">gridpositions</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">),</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">gridconnections</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;density&#39;</span><span class="p">,</span><span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span><span class="n">comments</span><span class="o">=</span><span class="n">comments</span><span class="p">)</span>
        <span class="n">dx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="n">grid_type</span> <span class="o">=</span> <span class="s">&#39;density&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_type</span> <span class="o">=</span> <span class="s">&#39;histogram&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s">&#39;and default filename &quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">())</span><span class="o">+</span><span class="s">&#39;&quot;&#39;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">return</span> <span class="s">&#39;&lt;hop.sitemap.Grid &#39;</span><span class="o">+</span><span class="n">grid_type</span><span class="o">+</span><span class="s">&#39; with &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; bins &#39;</span><span class="o">+</span><span class="n">fn</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>
    
</div>
<div class="viewcode-block" id="Density"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density">[docs]</a><span class="k">class</span> <span class="nc">Density</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class with an annotated density, i.e. additional information</span>
<span class="sd">    for each grid cell. Adds information about sites to the grid. A</span>
<span class="sd">    &#39;site&#39; consists of all connected grid cells with a density &gt;=</span>
<span class="sd">    threshold.</span>

<span class="sd">    A site is defined as a set of at least &#39;MINsite&#39; grid cells with</span>
<span class="sd">    density &gt;= threshold that are located in each others&#39; first and</span>
<span class="sd">    second nearest neighbour shell (of 26 cells, on the cubic</span>
<span class="sd">    lattice). A site is labelled by an integer 1..N. The interstitial</span>
<span class="sd">    is labelled &#39;0&#39;. By default, a site may consist of a single grid</span>
<span class="sd">    cell (MINsite == 1) but this can be changed by setting the</span>
<span class="sd">    parameter MINsite to another number &gt;1.</span>

<span class="sd">    When neither grid nor edges are given then the density object can</span>
<span class="sd">    also be read from a pickled file (filename) or a OpenDX file</span>
<span class="sd">    (dxfile). In the latter case, care should be taken to properly set</span>
<span class="sd">    up the units and the isDensity parameter:</span>

<span class="sd">    &gt;&gt;&gt; g = Density(dxfile=&#39;bulk.dx&#39;,parameters={&#39;isDensity&#39;:True,&#39;MINsite&#39;:1},</span>
<span class="sd">                    unit={&#39;length&#39;:&#39;Angstrom&#39;,&#39;density&#39;:&#39;Angstrom&#39;}, ....)</span>

<span class="sd">    Attributes:</span>

<span class="sd">        grid          density on a grid</span>
<span class="sd">        edges         the lower and upper edges of the grid cells along the</span>
<span class="sd">                      three dimensions of the grid</span>
<span class="sd">        map           grid with cells labeled as sites (after label_sites())</span>
<span class="sd">        sites         list of sites: site 0 is the interstitial, then follows</span>
<span class="sd">                      the largest site, and then sites in decreasing order.</span>
<span class="sd">                      Each site is a list of tuples. Each tuple is the index</span>
<span class="sd">                      (i,j,k) into the map or grid.</span>
<span class="sd">        graph         NetworkX graph of the cells</span>

<span class="sd">        unit          physical units of various components</span>
<span class="sd">        P             (default) values of parameters</span>

<span class="sd">    Methods:</span>

<span class="sd">        map_sites(threshold)</span>
<span class="sd">                        label all sites, defined by the threshold. The threshold</span>
<span class="sd">                        value is stored with the object as the default. The default</span>
<span class="sd">                        can be explicitly set as P[&#39;threshold&#39;]</span>
<span class="sd">        save(filename)  save object.pickle </span>
<span class="sd">        load(filename)  restore object.pickle (or use d=Density(filename=&lt;filename&gt;))</span>
<span class="sd">        export()        write density to a file for visualization</span>
<span class="sd">        export_map()    write individual sites</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># will probably break under multiple inheritance but I haven&#39;t figured out how to use super here</span>
    <span class="n">_saved_attributes</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">_saved_attributes</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;map&#39;</span><span class="p">,</span><span class="s">&#39;sites&#39;</span><span class="p">,</span><span class="s">&#39;site_properties&#39;</span><span class="p">,</span><span class="s">&#39;equivalent_sites_index&#39;</span><span class="p">]</span>

    <span class="c"># offsets to calculate first neighbours in the first octant</span>
    <span class="n">__delta_first_octant__</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">parameters_default</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;isDensity&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span> <span class="s">&#39;threshold&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;MINsite&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">unit_default</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;length&#39;</span><span class="p">:</span><span class="s">&#39;Angstrom&#39;</span><span class="p">,</span> <span class="s">&#39;density&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dxfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">parameters</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds information about sites to the grid. Sites are all</span>
<span class="sd">        cells with a density &gt;= threshold.</span>

<span class="sd">        density = Density(kargs**)</span>

<span class="sd">        Sets up a Grid with additional data, namely the site map The</span>
<span class="sd">        threshold is given as key-value pair in the parameters</span>
<span class="sd">        dictionary and is assumed to be in the same units as the</span>
<span class="sd">        density.</span>

<span class="sd">        If the input grid is a histogram then it is transformed into a</span>
<span class="sd">        density.</span>

<span class="sd">        When neither grid nor edges are given then the density object</span>
<span class="sd">        can also be read from a pickled file (filename) or a OpenDX</span>
<span class="sd">        file (dxfile). In the latter case, care should be taken to</span>
<span class="sd">        properly set up the units and the isDensity parameter if the</span>
<span class="sd">        dx file is a density:</span>

<span class="sd">        &gt;&gt;&gt; g = Density(dxfile=&#39;bulk.dx&#39;,parameters={&#39;isDensity&#39;:True},</span>
<span class="sd">                    unit={&#39;length&#39;:&#39;Angstrom&#39;,&#39;density&#39;:&#39;Angstrom&#39;}, ....)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters_default</span><span class="p">,</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;MINsite&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;MINsite must be &gt; 0 (site must contain at least one cell)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;MINsite&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Currently only MINsite == 1 or 2 is supported.&quot;</span><span class="p">)</span>        
        <span class="n">unit</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_default</span><span class="p">,</span><span class="n">unit</span><span class="p">)</span>        
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">DefaultDict</span><span class="p">({},</span><span class="n">metadata</span><span class="p">)</span>
        
        <span class="c"># not necessary to initialize</span>
        <span class="c">#self.graph = NX.Graph()      # nodes are indices (x,y,z) in isSite/grid</span>
        <span class="c">#self.graph.name = &#39;density&#39;  # graph.info() ...</span>
        
        <span class="c"># All initialisations MUST come before calling Grid.__init__() because</span>
        <span class="c"># of the crappy way that loading from a file is set up. (Otherwise I would overwrite</span>
        <span class="c"># the loaded values.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="n">Grid</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span><span class="n">dxfile</span><span class="o">=</span><span class="n">dxfile</span><span class="p">,</span>
                      <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_density</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span> <span class="c"># inconsistent with load() ?</span>

<div class="viewcode-block" id="Density.map_sites"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.map_sites">[docs]</a>    <span class="k">def</span> <span class="nf">map_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find regions of connected density and label them consecutively</span>

<span class="sd">        map_sites([threshold=&lt;threshold&gt;])</span>


<span class="sd">        threshold      Use the given threshold to generate the graph; the threshold</span>
<span class="sd">                       is assumed to be in the same units as the density.</span>
<span class="sd">                       (This updates the Density object&#39;s threshold value as well.)</span>

<span class="sd">        The interstitial has label &#39;0&#39;, the largest connected subgraph</span>
<span class="sd">        has &#39;1&#39; etc. The sites (i.e.the list of indices into map/grid)</span>
<span class="sd">        can be accesed as Density.sites[label].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>    
                <span class="n">threshold</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span><span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;A threshold density is required to map the sites.&quot;</span><span class="p">)</span>

        <span class="c"># first clean up</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_equivalence_sites</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_remove_bulk</span><span class="p">()</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Removed bulk site in order to map sites. Add it again when this is done!&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c"># map charts the sites. It starts out with the interstitial labeled</span>
        <span class="c"># as 0 and everything else 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">],</span>
                               <span class="mi">1</span><span class="p">,</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_connected_graphs</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Density.map_hilo"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.map_hilo">[docs]</a>    <span class="k">def</span> <span class="nf">map_hilo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lomin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">lomax</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">himin</span><span class="o">=</span><span class="mf">2.72</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;**Experimental** mapping of low density sites together with high density ones.</span>
<span class="sd">        </span>
<span class="sd">        :Keywords:</span>
<span class="sd">          *lomin*</span>
<span class="sd">              low-density sites must have a density &gt; *lomin* [0.0]</span>
<span class="sd">          *lomax*</span>
<span class="sd">              low-density sites must have a density &lt; *lomax* [0.5]</span>
<span class="sd">          *himin*</span>
<span class="sd">              high-density sites must have a density &gt; *himin* [2.72]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;lomin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lomin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;lomax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lomax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;himin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">himin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;himin&#39;</span><span class="p">]</span>  <span class="c"># is this a good idea?</span>

        <span class="c"># first clean up</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_equivalence_sites</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_remove_bulk</span><span class="p">()</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Removed bulk site in order to map sites. Add it again when this is done!&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c"># map charts the sites. It starts out with the interstitial labeled</span>
        <span class="c"># as 0 and everything else 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lomin</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">&lt;</span> <span class="n">lomax</span><span class="p">),</span> <span class="c"># low-density sites</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">&gt;</span> <span class="n">himin</span><span class="p">),</span>                                      <span class="c"># high-density sites</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_connected_graphs</span><span class="p">()</span>


    <span class="c"># &#39;site&#39; functions (should make site a class)</span></div>
<div class="viewcode-block" id="Density.site_occupancy"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_occupancy">[docs]</a>    <span class="k">def</span> <span class="nf">site_occupancy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">labelargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the labels and the average/stdev occupancy of the labeled site(s).</span>

<span class="sd">        labels, &lt;N&gt;, std(N) = site_coocupancy(include=&#39;all&#39; | &lt;int&gt; | &lt;list&gt;)</span>

<span class="sd">        Average occupancy is the average number of water molecules on the site i:</span>

<span class="sd">           &lt;N_i&gt; = &lt;n_i&gt; * V_i</span>

<span class="sd">        where n_i is the average density of the site and V_i its volume.</span>

<span class="sd">        The label selection arguments are directly passed to</span>
<span class="sd">        site_labels() (see doc string).</span>

<span class="sd">        If the interstitial is included then 0,0 is returned for the</span>
<span class="sd">        interstitial site (so ignore those numbers).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="o">**</span><span class="n">labelargs</span><span class="p">)</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">props</span><span class="o">.</span><span class="n">occupancy_avg</span><span class="p">,</span> <span class="n">props</span><span class="o">.</span><span class="n">occupancy_std</span>
        </div>
<div class="viewcode-block" id="Density.site_volume"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_volume">[docs]</a>    <span class="k">def</span> <span class="nf">site_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">labelargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the label(s) and volume(s) of the selected sites.</span>

<span class="sd">        labels, volumes = site_volume(&#39;all&#39;)</span>

<span class="sd">        The volume is calculated in the unit set in</span>
<span class="sd">        unit[&#39;length&#39;]. The label selection arguments are directly</span>
<span class="sd">        passed to site_labels() (see doc string).</span>

<span class="sd">        The volume of the interstitial (if included) is returned as 0</span>
<span class="sd">        (which is not correct but for technical reasons more</span>
<span class="sd">        convenient).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="o">**</span><span class="n">labelargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">volume</span>

    <span class="c"># methods to calculate site_properties</span></div>
    <span class="k">def</span> <span class="nf">_site_occupancies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s">&#39;density&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;density&#39;</span><span class="p">],</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">])</span>
        <span class="n">Vcell</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">occupancy</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
            <span class="n">V</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> <span class="o">*</span> <span class="n">Vcell</span>
            <span class="k">if</span> <span class="n">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># interstitial</span>
                <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">site</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">occupancy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_site_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">Vcell</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Vcell</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_site_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns geometric centers of sites or None for the interstitial.&quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span>
        <span class="k">def</span> <span class="nf">cellcenter</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">site</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">site</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
        <span class="k">def</span> <span class="nf">average_or_none</span><span class="p">(</span><span class="n">sites</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">cellcenter</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">average_or_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>

<div class="viewcode-block" id="Density.site_labels"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_labels">[docs]</a>    <span class="k">def</span> <span class="nf">site_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">include</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of site labels, possibly filtered.</span>

<span class="sd">        L = site_labels(include=&lt;inclusions&gt;,exclude=&lt;exclusions&gt;)</span>

<span class="sd">        &lt;inclusions&gt; and &lt;exclusions&gt; consist of a list of site labels</span>
<span class="sd">        (integers) and/or keywords that describe a site selection. All entries</span>
<span class="sd">        in one list are logically ORed. All exclusions are then removed from</span>
<span class="sd">        the inclusions and the final list of site labels is returned as a numpy</span>
<span class="sd">        array. (As a special case, the argument need not be a list but can be a</span>
<span class="sd">        single keyword or site label).</span>

<span class="sd">        For convenience, some inclusions such as &#39;subsites&#39; and</span>
<span class="sd">        &#39;equivalencesites&#39; automatically remove themselves from the exclusions.</span>

<span class="sd">        For standard use the defaults should do what you expect, i.e. only see</span>
<span class="sd">        the sites that are relevant or that have been mapped in a hopping</span>
<span class="sd">        trajectory.</span>

<span class="sd">        Set verbosity to 10 in order to see the parsed selection.</span>

<span class="sd">        &lt;inclusions&gt;</span>
<span class="sd">          &#39;all&#39;       all mapped sites, including bulk and subsites of </span>
<span class="sd">                      equivalent sites (but read the NOTE below: set exclude=None)</span>
<span class="sd">          &#39;default&#39;   all mapped sites, including bulk but excluding subsites</span>
<span class="sd">                      and interstitial</span>
<span class="sd">          &#39;sites&#39;     all mapped sites, excluding bulk and interstitial</span>
<span class="sd">                      (removes &#39;subsites&#39; and &#39;equivalencesites&#39; from</span>
<span class="sd">                      exclusions)</span>
<span class="sd">          &#39;subsites&#39;  all sites that have been renamed or aggreated into equivalence sites</span>
<span class="sd">          &#39;equivalencesites&#39; </span>
<span class="sd">                      only the equivalence sites</span>
<span class="sd">          int, list   site label(s)</span>

<span class="sd">        &lt;exclusions&gt;</span>
<span class="sd">          &#39;default&#39;    equivalent to [&#39;interstitial&#39;,&#39;subsites&#39;]; always applied unless </span>
<span class="sd">                       exludsions=None is set!</span>
<span class="sd">          None         do not apply any exclusions</span>
<span class="sd">          &#39;interstitial&#39;</span>
<span class="sd">                       exclude interstitial (almost no reason to</span>
<span class="sd">                       ever include it)</span>
<span class="sd">          &#39;subsites&#39;   exclude sites that have been aggregated or</span>
<span class="sd">                       simply renamed as equivalence sites</span>
<span class="sd">          &#39;equivalencesites&#39;</span>
<span class="sd">                       exclude equivalence sites (and possibly include subsites)</span>
<span class="sd">          &#39;bulk&#39;       exclude the bulk site</span>

<span class="sd">        Provides the ordered list L of site labels, excluding sites listed in</span>
<span class="sd">        the exclude list. Site labels are integers, starting from &#39;0&#39; (the</span>
<span class="sd">        interstitial). These labels are the index into the site_properties[]</span>
<span class="sd">        and sites[] arrays.</span>

<span class="sd">        NOTE that by default the standard exclusions are already being applied</span>
<span class="sd">        to any &#39;include&#39;; if one really wants all sites one has to set</span>
<span class="sd">        exclude=None.</span>
<span class="sd">        </span>
<span class="sd">        Exclusions are applied _after_ inclusions.</span>

<span class="sd">        &#39;site&#39; discards the bulk site, self.P[&#39;bulk_site&#39;]; this parameter is</span>
<span class="sd">        automatically set when adding the bulk site with site_insert_bulk().</span>

<span class="sd">        See find_equivalence_sites_with() for more on equivalence sites and</span>
<span class="sd">        subsites. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;inclusions&#39;</span><span class="p">:</span>
                        <span class="p">{</span><span class="bp">None</span><span class="p">:[</span><span class="s">&#39;default&#39;</span><span class="p">],</span> <span class="s">&#39;default&#39;</span><span class="p">:[</span><span class="s">&#39;default&#39;</span><span class="p">],</span>
                         <span class="s">&#39;all&#39;</span><span class="p">:[</span><span class="s">&#39;all&#39;</span><span class="p">],</span> <span class="s">&#39;sites&#39;</span><span class="p">:[</span><span class="s">&#39;sites&#39;</span><span class="p">],</span> 
                         <span class="s">&#39;subsites&#39;</span><span class="p">:[</span><span class="s">&#39;subsites&#39;</span><span class="p">],</span>
                         <span class="s">&#39;equivalencesites&#39;</span><span class="p">:[</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">]},</span>
                    <span class="s">&#39;exclusions&#39;</span><span class="p">:</span>
                        <span class="p">{</span><span class="bp">None</span><span class="p">:[],</span> <span class="s">&#39;default&#39;</span><span class="p">:[</span><span class="s">&#39;interstitial&#39;</span><span class="p">,</span><span class="s">&#39;subsites&#39;</span><span class="p">],</span>
                         <span class="s">&#39;interstitial&#39;</span><span class="p">:[</span><span class="s">&#39;interstitial&#39;</span><span class="p">],</span> <span class="s">&#39;bulk&#39;</span><span class="p">:[</span><span class="s">&#39;bulk&#39;</span><span class="p">],</span>
                         <span class="s">&#39;subsites&#39;</span><span class="p">:[</span><span class="s">&#39;subsites&#39;</span><span class="p">],</span> <span class="s">&#39;equivalentsites&#39;</span><span class="p">:[</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">],</span>
                         <span class="s">&#39;equivalencesites&#39;</span><span class="p">:[</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">]}</span>
                    <span class="p">}</span>
        <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="n">_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>          <span class="c"># add a site label</span>
                    <span class="n">_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_args</span><span class="p">[</span><span class="n">kind</span><span class="p">]:</span>   <span class="c"># add a keyword</span>
                    <span class="n">_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_args</span><span class="p">[</span><span class="n">kind</span><span class="p">][</span><span class="n">x</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; must be a (list of)  keyword(s) from &quot;</span>\
                                         <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">all_args</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>\
                                         <span class="o">+</span><span class="s">&quot; or a (list of) integer(s) (i.e. site labels).&quot;</span><span class="p">)</span>
            <span class="n">_args</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">_args</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_args</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>   <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c"># change unique-stringified site labels back to ints</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">_args</span>
        
        <span class="n">inclusions</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">&#39;inclusions&#39;</span><span class="p">,</span><span class="n">include</span><span class="p">)</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">&#39;exclusions&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">remove_from</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">seq</span><span class="p">):</span>                     <span class="c"># should be a set but that&#39;s not in py2.3 ... but should use &#39;from set import Set as set&#39;</span>
            <span class="sd">&quot;&quot;&quot;my_list = remove_from(my_list, [a,b,c,...])&quot;&quot;&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>            <span class="c"># must be unique and a list</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">l</span>
            
        <span class="c">## TODO</span>
        <span class="c">## organize labels as set and make an sorted array at the end</span>
        <span class="c">##... site_labels = set(range(len(self.sites)))    # &#39;all&#39;</span>
        <span class="c">##... site_labels.intersection_update(labels)</span>
        <span class="c">##... def add_labels(labels):</span>
        <span class="c">##        site_labels.union_update(labels)</span>
        <span class="c">##list is filtered below</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">all_site_labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">))</span>    <span class="c"># &#39;all&#39;, but list is filtered below</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>                  <span class="c"># no sites to start with</span>

        <span class="c"># TODO: horrible code: this should be cleaned up so that the</span>
        <span class="c"># selections actually behave like proper boolean expressions</span>
        <span class="c"># (intersection and union) and not an idiosyncratic mess</span>
        <span class="n">site_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inclusion</span> <span class="ow">in</span> <span class="n">inclusions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusion</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span> <span class="ow">or</span> <span class="n">inclusion</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">exclusions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;subsites&#39;</span><span class="p">)</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_site_labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inclusion</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_site_labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inclusion</span> <span class="o">==</span> <span class="s">&#39;sites&#39;</span><span class="p">:</span>
                <span class="n">exclusions</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&#39;bulk&#39;</span><span class="p">,</span><span class="s">&#39;interstitial&#39;</span><span class="p">])</span>
                <span class="n">exclusions</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">exclusions</span><span class="p">,[</span><span class="s">&#39;subsites&#39;</span><span class="p">])</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_site_labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inclusion</span> <span class="o">==</span> <span class="s">&#39;equivalencesites&#39;</span><span class="p">:</span>
                <span class="n">exclusions</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">exclusions</span><span class="p">,[</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">])</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_equivalencesites</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">inclusion</span> <span class="o">==</span> <span class="s">&#39;subsites&#39;</span><span class="p">:</span>
                <span class="n">exclusions</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">exclusions</span><span class="p">,[</span><span class="s">&#39;subsites&#39;</span><span class="p">])</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_subsites</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inclusion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_site_labels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;site label </span><span class="si">%d</span><span class="s"> does not exist&#39;</span> <span class="o">%</span> <span class="n">inclusion</span><span class="p">)</span>
                <span class="n">site_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inclusion</span><span class="p">)</span>  <span class="c"># site label</span>
        
        <span class="n">inclusions</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">inclusions</span><span class="p">)</span>  <span class="c"># only for diagnostics</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>  <span class="c"># for the loop</span>
        <span class="k">for</span> <span class="n">exclusion</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclusion</span> <span class="o">==</span> <span class="s">&#39;interstitial&#39;</span><span class="p">:</span>
                <span class="n">site_labels</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">site_labels</span><span class="p">,</span> <span class="p">[</span><span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="n">exclusion</span> <span class="o">==</span> <span class="s">&#39;subsites&#39;</span><span class="p">:</span>
                <span class="n">site_labels</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">site_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_subsites</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">exclusion</span> <span class="o">==</span> <span class="s">&#39;equivalencesites&#39;</span><span class="p">:</span>
                <span class="n">site_labels</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">site_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_equivalencesites</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">exclusion</span> <span class="o">==</span> <span class="s">&#39;bulk&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">site_labels</span> <span class="o">=</span> <span class="n">remove_from</span><span class="p">(</span><span class="n">site_labels</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_site&#39;</span><span class="p">]])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="s">&quot;site_labels(): using include = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inclusions</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;  exclude = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">site_labels</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_labels_subsites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">equivalence_site</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>   <span class="c"># should not fail just because there are no equivsites</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_labels_equivalencesites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c"># should not fail just because there are no equivsites</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

<div class="viewcode-block" id="Density.subsites_of"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.subsites_of">[docs]</a>    <span class="k">def</span> <span class="nf">subsites_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">equivsites</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s">&#39;sitelabel&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return subsites of given equivalence sites as a dict.</span>

<span class="sd">        dict &lt;-- subsites_of(equivsites,kind=&#39;sitelabel&#39;)</span>

<span class="sd">        The dict is indexed by equivsite label. There is one list of subsites for</span>
<span class="sd">        each equivsitelabel.</span>

<span class="sd">        kind      &#39;sitelabel&#39;:  equivsites are the sitelabels as uses internally; this is</span>
<span class="sd">                                the default because site_labels() returns these numbers and</span>
<span class="sd">                                so  one can  directly use the output from site_labels() as</span>
<span class="sd">                                input (see example)</span>
<span class="sd">                  &#39;equivlabel&#39;: equivsites are treated as labels of equivalence sites;</span>
<span class="sd">                                these are integers N that typically start at 2</span>
<span class="sd">                  &#39;name&#39;:       equivsites are treated as strings that are given as names</span>
<span class="sd">                                to sites; the default settings produce something like &#39;N*&#39;</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            dens.subsites_of(dens.site_labels(&#39;equivalencesites&#39;))</span>
<span class="sd">            dens.subsites_of([2,5,10], kind=&#39;equivsites&#39;)</span>
<span class="sd">            dens.subsites_of(&#39;10*&#39;, kind=&#39;name&#39;)</span>

<span class="sd">        NOTE:</span>
<span class="sd">        * equivlabel == 0 is silently filtered (it is used as a merker for NO equivalence</span>
<span class="sd">          site)</span>
<span class="sd">        * empty equivalence sites show up as empty entries in the output dict; typically</span>
<span class="sd">          this means that one gave the wrong input or kind        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_transform</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;sitelabel&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sitelabel2equivlabel</span><span class="p">,</span>
                      <span class="s">&#39;equivlabel&#39;</span><span class="p">:</span> <span class="n">asiterable</span><span class="p">,</span>
                      <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivname2equivlabel</span><span class="p">,</span>
                      <span class="p">}</span>
        <span class="n">SP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="n">subsites</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">equivsitelabels</span> <span class="o">=</span> <span class="n">_transform</span><span class="p">[</span><span class="n">kind</span><span class="p">](</span><span class="n">equivsites</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;kind must be one of </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">_transform</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c"># Must be a loop over equivlabels because one equivsite can contain many subsites</span>
        <span class="c"># and I cannot do this as a direct index: the data structure is too crappy for that.</span>
        <span class="k">for</span> <span class="n">equivsite</span> <span class="ow">in</span> <span class="n">equivsitelabels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">equivsite</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>   <span class="c"># hack: we are using &#39;0&#39; as marker for NO equivsite so skip it</span>
            <span class="n">subsites</span><span class="p">[</span><span class="n">equivsite</span><span class="p">]</span> <span class="o">=</span> <span class="n">SP</span><span class="p">[</span><span class="n">SP</span><span class="o">.</span><span class="n">equivalence_site</span> <span class="o">==</span> <span class="n">equivsite</span><span class="p">]</span> <span class="c"># sites referencing the equivsite</span>
        <span class="k">return</span> <span class="n">subsites</span>
</div>
    <span class="k">def</span> <span class="nf">_equivlabel2sitelabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">equivlabels</span><span class="p">):</span>
        <span class="c"># XXX: not needed at the moment/untested</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">equivlabels</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_equivlabel2equivname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">equivlabels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the equivalence name strings for the equivalence labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span>
                                    <span class="n">asiterable</span><span class="p">(</span><span class="n">equivlabels</span><span class="p">)]]</span><span class="o">.</span><span class="n">equivalence_name</span>
    
    <span class="k">def</span> <span class="nf">_sitelabel2equivlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sitelabels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return equivalence labels corresponding to the internal sitelabels.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="p">[</span><span class="n">asiterable</span><span class="p">(</span><span class="n">sitelabels</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">equivalence_label</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">equivalence_label</span>  <span class="c"># filter sites that are not equivsites</span>

    <span class="k">def</span> <span class="nf">_equivname2sitelabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">equivnames</span><span class="p">):</span>        
        <span class="sd">&quot;&quot;&quot;Return internal sitelabel (169,170,..) corresponding to equivname (&#39;2*&#39;, &#39;3*&#39;).&quot;&quot;&quot;</span>
        <span class="c"># XXX: not needed at the moment/untested        </span>
        <span class="n">SP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">([</span><span class="n">SP</span><span class="p">[</span><span class="n">SP</span><span class="o">.</span><span class="n">equivalence_name</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">equivnames</span><span class="p">)])</span>
        
    <span class="k">def</span> <span class="nf">_equivname2equivlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">equivnames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return equivalence labels (2.3,..) corresponding to equivname (&#39;2*&#39;, &#39;3*&#39;).&quot;&quot;&quot;</span>        
        <span class="n">SP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">return</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span>
            <span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="n">SP</span><span class="o">.</span><span class="n">equivalence_name</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span><span class="o">.</span><span class="n">equivalence_label</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">equivnames</span><span class="p">)])</span>
        
            
<div class="viewcode-block" id="Density.site_insert_bulk"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_insert_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">site_insert_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bulkdensity</span><span class="p">,</span><span class="n">bulklabel</span><span class="o">=</span><span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">],</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert a bulk site from a different density map as bulk site into this density.</span>

<span class="sd">        site_insert_bulk(bulkdensity)</span>

<span class="sd">        This is a bit of a hack. The idea is that one can use a site</span>
<span class="sd">        from a different map (computed from the same trajectory with</span>
<span class="sd">        the same grid!) and insert it into the current site map to</span>
<span class="sd">        define a different functional region. Typically, the bulk site</span>
<span class="sd">        is the largest site in bulkdensity (and has site label 1) but</span>
<span class="sd">        if this is not the case manually choose the appropriate</span>
<span class="sd">        bulklabel.</span>

<span class="sd">        The site is always inserted as the bulk site in the current density.</span>

<span class="sd">        Example:</span>
<span class="sd">        &gt;&gt;&gt; bulkdensity = hop.interactive.make_density(psf,dcd,&#39;bulk&#39;,delta=1.0,</span>
<span class="sd">                                atomselection=&#39;name OH2 and not within 4.0 of protein&#39;)</span>
<span class="sd">        &gt;&gt;&gt; bulkdensity.map_sites(threshold=0.6)</span>
<span class="sd">        &gt;&gt;&gt; density.site_insert_bulk(bulkdensity)</span>
<span class="sd">        &gt;&gt;&gt; density.save()</span>
<span class="sd">        &gt;&gt;&gt; del bulkdensity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># sanity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;bulk_site&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The density already contains a bulk site. Use &#39;</span>
                               <span class="s">&#39;force=True to override.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">bulkdensity</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Both densities must have had their map computed.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">bulkdensity</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The bulk density was defined on a different grid than this density.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bulkdensity</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The unit for the density (</span><span class="si">%s</span><span class="s">) is different from the unit &quot;</span>
                          <span class="s">&quot;for the bulk density (</span><span class="si">%s</span><span class="s">).</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">],</span> <span class="n">bulkdensity</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]),</span>
                          <span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">InconsistentDataWarning</span><span class="p">)</span>
        <span class="c"># do the hack &amp; update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">],</span><span class="n">bulkdensity</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">bulklabel</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_site&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkdensity</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Density.site_remove_bulk"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_remove_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">site_remove_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cleanup bulk site.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_site_remove_bulk</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_site_remove_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;bulk_site&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No bulk site is recorded but force=True would do it&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_site&#39;</span><span class="p">]]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_site&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_threshold&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Density.site_insert_nobulk"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.site_insert_nobulk">[docs]</a>    <span class="k">def</span> <span class="nf">site_insert_nobulk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an empty bulk site for cases when this is convenient.&quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">Nobulk</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dens</span><span class="p">):</span>
                <span class="c"># copy the attributes that are checked in Density.site_insert_bulk()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">dens</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">dens</span><span class="o">.</span><span class="n">unit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;threshold&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
                <span class="c"># minimum empty sites &#39;list&#39;                </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="p">{</span><span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]:</span> <span class="p">()}</span>  <span class="c"># normally a list but use a dict :-)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_insert_bulk</span><span class="p">(</span><span class="n">Nobulk</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Density.has_bulk"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.has_bulk">[docs]</a>    <span class="k">def</span> <span class="nf">has_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if a bulk site has been inserted and ``False`` otherwise.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_site&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Density.masked_density"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.masked_density">[docs]</a>    <span class="k">def</span> <span class="nf">masked_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">density</span><span class="p">,</span><span class="n">site_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns only that portion of density that corresponds to</span>
<span class="sd">        sites; everything else is zeroed.</span>

<span class="sd">        masked = masked_density(density,sites)</span>

<span class="sd">        Arguments:</span>

<span class="sd">        density       a array commensurate with the map</span>
<span class="sd">        site_labels   label or list of site labels</span>

<span class="sd">        Results:</span>

<span class="sd">        Returns numpy array of same shape as input with non-site cells zeroed.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_map</span><span class="p">()</span>             <span class="c"># minimum sanity checks</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Input &quot;density&quot; must have same shape as map.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">site_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span> <span class="c">#  (numpy.int32 == scalar -&gt; IndexError change in numpy...)</span>
            <span class="n">site_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">site_labels</span><span class="p">]</span>
        <span class="c"># logical OR all site maps and return corresponding entries in d</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">==</span> <span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">site_labels</span><span class="p">])</span>

        </div>
<div class="viewcode-block" id="Density.export_map"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.export_map">[docs]</a>    <span class="k">def</span> <span class="nf">export_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;dx&#39;</span><span class="p">,</span><span class="n">directory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">value</span><span class="o">=</span><span class="s">&#39;density&#39;</span><span class="p">,</span><span class="n">combined</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write sites as a density file for visualization.</span>

<span class="sd">        export_map(**kwargs)</span>

<span class="sd">        labels=&#39;default&#39;  Select the sites that should be exported. Can be</span>
<span class="sd">                           a list of numbers (site labels) or one of the keywords </span>
<span class="sd">                           recognized by site_labels() (qv). The interstitial is</span>
<span class="sd">                           always excluded.</span>
<span class="sd">        combined=False     True: write one file. False: write one file for each</span>
<span class="sd">                           site.</span>
<span class="sd">        format=&#39;dx&#39;        Only dx format supported</span>
<span class="sd">        directory=&#39;site_maps&#39;</span>
<span class="sd">                           Files are created in new directory, &#39;site_maps&#39; by</span>
<span class="sd">                           default. File names are generated and indexed with</span>
<span class="sd">                           the label of the site. By default, &#39;site_maps&#39; is</span>
<span class="sd">                           located in the same directory as the default filename.</span>
<span class="sd">        value= &#39;density&#39;   Writes the actual density in the site.</span>
<span class="sd">               &#39;threshold&#39; The densities have the threshold value wherever the</span>
<span class="sd">                           site is defined. Note that the interstitial (label = 0)</span>
<span class="sd">                           is also written.</span>
<span class="sd">               &lt;float&gt;     Writes the value &lt;float&gt; into the site.</span>
<span class="sd">        verbosity=3        Set to 0 to disable status messages.</span>

<span class="sd">        Quick hack to write out sites. Each site can be written as a</span>
<span class="sd">        separate density file (combined=False) so that one can distinguish them</span>
<span class="sd">        easily in say VMD. Display with</span>
<span class="sd">           vmd site_maps/*.dx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_map</span><span class="p">()</span>        <span class="c"># minimum sanity checks</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>
        <span class="c"># opt processing</span>
        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parentdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">parentdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span>  <span class="c"># no default filename, so use cwd</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parentdir</span><span class="p">,</span><span class="s">&#39;site_maps&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">os</span><span class="o">.</span><span class="n">error</span><span class="p">,</span><span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;Created site map directory &quot;</span><span class="si">%s</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">directory</span><span class="p">)</span>
        <span class="c"># interstitial map MUST be excluded for &#39;painting over&#39; to work</span>
        <span class="n">site_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;threshold&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">sitemap</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">==</span> <span class="n">label</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;density&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">sitemap</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;value must be a number or &#39;threshold&#39; or &#39;density&#39;.&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">sitemap</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">==</span> <span class="n">label</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
            
        <span class="k">def</span> <span class="nf">export_site_dx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">comments</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">gridpositions</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">),</span>
                <span class="n">connections</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">gridconnections</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">g</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">OpenDX</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;site map &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">),</span>
                              <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span><span class="n">comments</span><span class="o">=</span><span class="n">comments</span><span class="p">)</span>
            <span class="n">dx</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;Exported density </span><span class="si">%3s</span><span class="s"> to file &quot;</span><span class="si">%s</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">),</span><span class="n">filename</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">combined</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                                    <span class="s">&#39;sitemap_combined__</span><span class="si">%.2f</span><span class="s">.dx&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">threshold</span><span class="p">))</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">sitemap</span><span class="p">(</span><span class="n">site_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>      <span class="c"># first sitemap as basis (with its interstitial)</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">site_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">smap</span> <span class="o">=</span> <span class="n">sitemap</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>        <span class="c"># set any values that are not interstitial in smap</span>
                <span class="n">sites</span> <span class="o">=</span>  <span class="n">smap</span> <span class="o">!=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">]</span>                         
                <span class="n">g</span><span class="p">[</span><span class="n">sites</span><span class="p">]</span> <span class="o">=</span> <span class="n">smap</span><span class="p">[</span><span class="n">sites</span><span class="p">]</span>       <span class="c"># &#39;paint over&#39; previous values at sites</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s">&#39;OpenDX density file written by export_map(combined=True),&#39;</span><span class="p">,</span>
                <span class="s">&#39;$Id$&#39;</span><span class="p">,</span>
                <span class="s">&#39;</span><span class="se">\t</span><span class="s"> value at site is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="s">&#39;</span><span class="se">\t</span><span class="s"> threshold  = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="n">export_site_dx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">comments</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">site_labels</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">sitemap</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                                        <span class="s">&#39;sitemap_</span><span class="si">%04d</span><span class="s">__</span><span class="si">%.2f</span><span class="s">.dx&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">threshold</span><span class="p">))</span>
                <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s">&#39;OpenDX density file written by export_map(),&#39;</span><span class="p">,</span>
                    <span class="s">&#39;$Id$&#39;</span><span class="p">,</span>
                    <span class="s">&#39;</span><span class="se">\t</span><span class="s"> value at site is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                    <span class="s">&#39;</span><span class="se">\t</span><span class="s"> threshold  = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">),</span>
                    <span class="s">&#39;</span><span class="se">\t</span><span class="s"> site_label = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="n">export_site_dx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">comments</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Density.find_equivalence_sites_with"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.find_equivalence_sites_with">[docs]</a>    <span class="k">def</span> <span class="nf">find_equivalence_sites_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reference</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">*&#39;</span><span class="p">,</span><span class="n">update_reference</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">use_ref_equivalencesites</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                    <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">equivalence_graph</span><span class="o">=</span><span class="s">&#39;equivalence_graph.png&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find overlapping sites with a reference density and update site descriptions.</span>

<span class="sd">        Density.find_equivalence_sites_with(ref)</span>

<span class="sd">        :Arguments:</span>
<span class="sd">        ref         a Density object defined on the same grid</span>
<span class="sd">        fmt         python format string used for the equivalent_name, which should</span>
<span class="sd">                    contain %d for the reference label number (max 10 chars)</span>
<span class="sd">                    (but see below for magical use of xray water names)        </span>
<span class="sd">        update_reference</span>
<span class="sd">                    True (default): Also update the site_properties in the</span>
<span class="sd">                    *reference* so that one can make graphs that highlight the</span>
<span class="sd">                    common sites. (This is recommended.)</span>
<span class="sd">                    False: don&#39;t change the reference</span>
<span class="sd">        use_ref_equivalencesites</span>
<span class="sd">                    True: use sites + equivalence sites from the reference density</span>
<span class="sd">                    False*: remove all equivalence sites als from the ref density</span>
<span class="sd">        verbosity   For verbosity &gt;= 3 output some statistics; verbosity &gt;=5 also </span>
<span class="sd">                    returns the equivalence graph for analysis; verbosity &gt;= 7 </span>
<span class="sd">                    displays the graph (and saves to equivalence_graph.png).</span>

<span class="sd">        An &#39;equivalence site&#39; is a site that contains all sites that</span>
<span class="sd">        overlap in real space with another site in the reference</span>
<span class="sd">        density. This also means that two or more sites in one density</span>
<span class="sd">        can become considered equivalent if they both overlap with a</span>
<span class="sd">        larger site in the other density, and it is also possible that</span>
<span class="sd">        one creates &#39;equivalence&#39; chains (0,a) &lt;-&gt; (1,b) &lt;-&gt; (0,c) &lt;-&gt;</span>
<span class="sd">        (1,d) (although (0,a) ~&lt;-&gt; (1,d), and by construction (0,a) ~&lt;-&gt;</span>
<span class="sd">        (0,c) and (1,b) ~&lt;-&gt; (1,d)), leading to extensive equivalence</span>
<span class="sd">        sites.</span>

<span class="sd">        When hopping properties are computed, an equivalence site is</span>
<span class="sd">        used instead of the individual sub sites.</span>

<span class="sd">        The equivalence sites themselves are constructed as new sites</span>
<span class="sd">        and added to the list of sites; their site numbers are</span>
<span class="sd">        constructed by adding to the total number of existing</span>
<span class="sd">        sites. Sub-sites are marked up by an entry of the equivalence</span>
<span class="sd">        site&#39;s site number in site_properties.equivalence_site.</span>

<span class="sd">        The common sites are consecutively numbered, starting at 2,</span>
<span class="sd">        from the one containing most sites to the one with fewest.</span>

<span class="sd">        The method updates Density.site_properties.equivalent_name</span>
<span class="sd">        with the new descriptor of the equivalent site. Equivalent</span>
<span class="sd">        site names are consecutively numbered, starting at 2, and can</span>
<span class="sd">        be optionally formatted with the fmt argument.</span>

<span class="sd">        However, if the reference density was built from an X-ray density AND if</span>
<span class="sd">        each site corresponds to single X-ray water molecule then the</span>
<span class="sd">        equivalence names contain the water identifiers eg &#39;W136&#39; or</span>
<span class="sd">        &#39;W20_W34_W36&#39;.</span>

<span class="sd">        See the hop.sitemap.find_common_sites() function for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">original_verbosity</span> <span class="o">=</span> <span class="n">get_verbosity</span><span class="p">()</span>  <span class="c"># change verbosity temporarily</span>
        <span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>

        <span class="c"># Find sites in density 0 and 1 that overlap in space:</span>
        <span class="c"># 1) get mapping</span>
        <span class="c"># 2) interprete mapping as a graph with nodes the sites in each </span>
        <span class="c">#    density; a node is a tuple (density,site), eg (0,23) or (1,117).</span>
        <span class="c"># 3) mapping induces edges: the connected subgraphs constitute the common sites</span>
        <span class="c"># 4) list connected subgraphs consecutively and use its ordinal as the common </span>
        <span class="c">#    site label</span>
        <span class="n">densities</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">]</span>                         <span class="c"># 0 = self, 1 = reference</span>
        <span class="n">SELF</span><span class="p">,</span><span class="n">REF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span>

        <span class="k">def</span> <span class="nf">warn_and_remove</span><span class="p">(</span><span class="n">density</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">density</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Density &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">density</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; already contains equivalent sites, &#39;</span>
                              <span class="s">&#39;which will be overwritten.&#39;</span><span class="p">,</span>
                              <span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">OverwriteWarning</span><span class="p">)</span>
                <span class="n">density</span><span class="o">.</span><span class="n">remove_equivalence_sites</span><span class="p">()</span>
        <span class="n">warn_and_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_ref_equivalencesites</span><span class="p">:</span>
            <span class="n">warn_and_remove</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;equivalence sites: use equivalence sites from reference: </span><span class="si">%r</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="o">%</span> <span class="n">use_ref_equivalencesites</span><span class="p">)</span>
        <span class="c"># if we use_ref_equivalencesites then we keep the reference map that has</span>
        <span class="c"># equivalence sites painted in; thus all matching will be done against</span>
        <span class="c"># equivalence sites which act as ordinary sites</span>
        <span class="c">#</span>
        <span class="c"># TODO: Still cannot keep equivalence_names for the NEW equiv sites.</span>
        <span class="c">#       Perhaps a new naming scheme which concatenates site numbers or uses</span>
        <span class="c">#       a concatentaion of all equiv names if they already exist?</span>

        <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;equivalence sites: finding mapping and analysing equivalence graph</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">find_common_sites</span><span class="p">(</span><span class="n">densities</span><span class="p">[</span><span class="n">SELF</span><span class="p">],</span><span class="n">densities</span><span class="p">[</span><span class="n">REF</span><span class="p">])</span> <span class="c"># mapping site_i(0) &lt;--&gt; site_k(1)</span>
	<span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>   <span class="c"># (0,site_i(0)) &lt;---&gt; (1,site_k(1))</span>
        <span class="n">edges</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">SELF</span><span class="p">,</span><span class="n">REF</span><span class="p">]</span>       <span class="c"># identifier for density 0 and density 1</span>
        <span class="n">edges</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>                <span class="c"># fill second field with corresponding node/site label</span>
	<span class="n">ebunch</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>  <span class="c"># make nodes hashable tuples</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
        <span class="n">commonsites</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>  <span class="c"># each item: collection of equivalent sites</span>

	<span class="c"># liz overlap</span>
	<span class="n">overlap</span> <span class="o">=</span> <span class="n">find_overlap_coeff</span><span class="p">(</span><span class="n">densities</span><span class="p">[</span><span class="n">SELF</span><span class="p">],</span><span class="n">densities</span><span class="p">[</span><span class="n">REF</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">update_reference</span><span class="p">:</span>
            <span class="n">densities_to_update</span> <span class="o">=</span> <span class="p">{</span><span class="n">SELF</span><span class="p">:</span><span class="n">densities</span><span class="p">[</span><span class="n">SELF</span><span class="p">],</span><span class="n">REF</span><span class="p">:</span><span class="n">densities</span><span class="p">[</span><span class="n">REF</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">densities_to_update</span> <span class="o">=</span> <span class="p">{</span><span class="n">SELF</span><span class="p">:</span><span class="n">densities</span><span class="p">[</span><span class="n">SELF</span><span class="p">]}</span>
	
        <span class="c"># Book keeping: site_properties is the central and messy data</span>
        <span class="c"># structure; see _annotate_sites()</span>
        <span class="c">#</span>
        <span class="c"># dirty update of sites and site_properties:</span>
        <span class="c">#   1) add equivalence sites to self.sites</span>
        <span class="c">#   2) self._draw_map_from_sites() --- overwrites sub-sites with equivalence</span>
        <span class="c">#   3) self._annotate_sites() recreates self.site_properties with equivalence</span>
        <span class="c">#      sites at end</span>
        <span class="c">#   4) add additional markup for equivalence sites</span>
        <span class="c"># NOTE: another _annotate_sites() will destroy the additional markup (perhaps</span>
        <span class="c">#       put the additional markup into __annotate_sites(), too ?)</span>
        <span class="c"># Note: The original sites do not know the actual label of the site (the index</span>
        <span class="c">#       in site and site_propeties) but only the equivalence site label</span>
        <span class="c">#       which, however, is identical across the densities. So add extra dict:</span>
        <span class="k">for</span> <span class="n">density</span> <span class="ow">in</span> <span class="n">densities_to_update</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">density</span><span class="o">.</span><span class="n">equivalent_sites_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c"># equiv. label --&gt; index in sites </span>

        <span class="c"># 1)</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;equivalence sites: creating equivalence sites</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">isite</span><span class="p">,</span><span class="n">commonsite</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">commonsites</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">isite</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># labels start after &#39;bulk&#39;</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">commonsite</span><span class="p">)</span>           <span class="c"># array of sites [[0,23],[1,17],[0,2],...]</span>
            <span class="k">for</span> <span class="n">idensity</span><span class="p">,</span><span class="n">density</span> <span class="ow">in</span> <span class="n">densities_to_update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">sitelabels</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idensity</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="c"># [23,2,...] for idensity == SELF==0</span>
                <span class="c"># would be simpler if sites was a numpy array...</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">density</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sitelabels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]))</span>
                <span class="n">density</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c"># add compound site to list of sites</span>
                <span class="n">sindex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c"># index in sites and site_properties</span>
                <span class="n">density</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">sindex</span>
        <span class="c"># 2) + 3) + 4)</span>
        <span class="c"># (horrible hack to get xray waters into equivalence_name)</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;equivalence sites: updating annotation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idensity</span><span class="p">,</span><span class="n">density</span> <span class="ow">in</span> <span class="n">densities_to_update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">density</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span> <span class="c"># density updated;equiv.sites overwrite subsites</span>
            <span class="n">density</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>      <span class="c"># recalculate all site stats</span>
            <span class="k">for</span> <span class="n">elabel</span><span class="p">,</span><span class="n">sindex</span> <span class="ow">in</span> <span class="n">density</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">density</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">equivalence_label</span><span class="p">[</span><span class="n">sindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">elabel</span>
                <span class="c"># construct a site name from x-ray waters in the reference density</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">isite</span> <span class="o">=</span> <span class="n">elabel</span> <span class="o">-</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c"># XXX: argh, horrible...</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">commonsites</span><span class="p">[</span><span class="n">isite</span><span class="p">])</span>      <span class="c"># subsites of elabel/isite</span>
                    <span class="n">sref</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REF</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>             <span class="c"># only REF subsite labels</span>
                    <span class="n">xraynames</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">W</span><span class="p">(</span>                 <span class="c"># only sites in REF...</span>
                        <span class="n">reference</span><span class="o">.</span><span class="n">site2resid</span><span class="p">(</span> <span class="n">sref</span> <span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># .. add Wxxx identfiers</span>
                    <span class="n">equivalence_name</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">xraynames</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span><span class="ne">NotImplementedError</span><span class="p">):</span>
                    <span class="c"># default if we cannot find xray waters</span>
                    <span class="n">equivalence_name</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">elabel</span>
                    <span class="c">#raise</span>
                <span class="n">density</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">equivalence_name</span><span class="p">[</span><span class="n">sindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">equivalence_name</span>
            <span class="k">for</span> <span class="n">isite</span><span class="p">,</span><span class="n">commonsite</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">commonsites</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">isite</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># labels start after &#39;bulk&#39;</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">commonsite</span><span class="p">)</span>           <span class="c"># array of sites [[0,23],[1,17],[0,2],...]</span>
                <span class="n">sitelabels</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idensity</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="c"># [23,2,...] for idensity == SELF==0</span>
                <span class="n">density</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">equivalence_site</span><span class="p">[</span><span class="n">sitelabels</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
                            
        <span class="c"># statistics and liz&#39;s stupid hack for probability overlap of equivalent sites</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;equivalence sites: statistics for </span><span class="si">%d</span><span class="s"> equivalent sites</span><span class="se">\n</span><span class="s">&quot;</span> \
                    <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">commonsites</span><span class="p">))</span>
	    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;self density sites are now labelled according to the remapped density: thus density.sites[n] will&quot;</span>
	          <span class="s">&quot; NOT be equal to &#39;n&#39; in &#39;sites&#39; (0,n)&quot;</span><span class="p">)</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;[</span><span class="si">%5s</span><span class="s">]  </span><span class="si">%5s</span><span class="s">  </span><span class="si">%5s</span><span class="s"> </span><span class="si">%5s</span><span class="s">  |   </span><span class="si">%s</span><span class="s">   | </span><span class="si">%s</span><span class="s"> | </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">,</span><span class="s">&#39;total&#39;</span><span class="p">,</span><span class="s">&#39;self&#39;</span><span class="p">,</span><span class="s">&#39;ref&#39;</span><span class="p">,</span><span class="s">&#39;sites&#39;</span><span class="p">,</span><span class="s">&#39;overlap coeff&#39;</span><span class="p">,</span><span class="s">&#39;total_overlap&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">isite</span><span class="p">,</span><span class="n">commonsite</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">commonsites</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">isite</span> <span class="o">+</span> <span class="mi">1</span>    <span class="c"># labels start after &#39;bulk&#39;</span>
                <span class="n">labelstr</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">label</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">commonsite</span><span class="p">)</span>
                <span class="n">nsites</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idensity</span> <span class="ow">in</span> <span class="p">[</span><span class="n">SELF</span><span class="p">,</span><span class="n">REF</span><span class="p">]:</span>
                    <span class="n">sitelabels</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idensity</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nsites</span><span class="p">[</span><span class="n">idensity</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sitelabels</span><span class="p">)</span>
		<span class="c"># liz getting the probability overlap</span>
		<span class="n">oc</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">[</span><span class="n">isite</span><span class="p">]</span>
		<span class="k">print</span> <span class="n">oc</span>
                <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;[</span><span class="si">%5s</span><span class="s">]  </span><span class="si">%5d</span><span class="s">  </span><span class="si">%5d</span><span class="s"> </span><span class="si">%5d</span><span class="s">  |   </span><span class="si">%s</span><span class="s">   | </span><span class="si">%s</span><span class="s"> | </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> 
                    <span class="p">(</span><span class="n">labelstr</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">commonsite</span><span class="p">),</span><span class="n">nsites</span><span class="p">[</span><span class="n">SELF</span><span class="p">],</span><span class="n">nsites</span><span class="p">[</span><span class="n">REF</span><span class="p">],</span><span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">commonsite</span><span class="p">)),</span><span class="nb">str</span><span class="p">(</span><span class="n">oc</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">overlap</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="s">&quot;Plotting the equivalent sites graph; blue in this density, red in reference density</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">pylab</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">node_color</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">NX</span><span class="o">.</span><span class="n">draw_graphviz</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">node_color</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">font_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">linewidths</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,),</span>
                             <span class="n">labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">())</span>
            <span class="n">NX</span><span class="o">.</span><span class="n">draw_graphviz</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">node_color</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span><span class="n">font_size</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
            <span class="n">pylab</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">equivalence_graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;Returning equivalent-sites graph</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="n">set_verbosity</span><span class="p">(</span><span class="n">original_verbosity</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">g</span>
        <span class="n">set_verbosity</span><span class="p">(</span><span class="n">original_verbosity</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Density.remove_equivalence_sites"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.remove_equivalence_sites">[docs]</a>    <span class="k">def</span> <span class="nf">remove_equivalence_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete equivalence sites and recompute site map.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_equivalence_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_remove_equivalence_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eqs_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c"># nothing to be done</span>
        <span class="c"># Removing indexed items from a list is a bit iffy, and we can&#39;t do it sequentially.</span>
        <span class="c"># This hack relies on the fact that the equivalence sites form one continuous block.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">first</span><span class="p">,</span><span class="n">last</span> <span class="o">=</span> <span class="n">eqs_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eqs_labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c"># no eqs_labels</span>

<div class="viewcode-block" id="Density.stats"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.stats">[docs]</a>    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Statistics for the density (excludes bulk, interstitial, subsites).</span>

<span class="sd">        d = stats([data=dict])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;site_properties&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;Stats require site_properties annotation.&#39;</span><span class="p">)</span>        
        <span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">,</span><span class="s">&#39;interstitial&#39;</span><span class="p">,</span><span class="s">&#39;subsites&#39;</span><span class="p">])</span>

        <span class="c"># General (meta data)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stats</span><span class="p">[</span><span class="s">&#39;rho_cut&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>
            <span class="n">stats</span><span class="p">[</span><span class="s">&#39;rho_cut_bulk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;bulk_threshold&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No bulk site defined&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">MissingDataWarning</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;N_sites&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;N_equivalence_sites&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="bp">None</span><span class="p">))</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;N_subsites&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s">&#39;subsites&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="bp">None</span><span class="p">))</span>

        <span class="c">#------------------------------------------------------------</span>
        <span class="c"># density stats</span>
        <span class="c">#------------------------------------------------------------</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;site_volume_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;site_volume_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;site_occupancy_rho_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">occupancy_avg</span><span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s">&#39;site_occupancy_rho_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">occupancy_avg</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s">&#39;site_volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">volume</span>
            <span class="n">data</span><span class="p">[</span><span class="s">&#39;site_occupancy_rho_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">occupancy_avg</span>
            <span class="n">data</span><span class="p">[</span><span class="s">&#39;site_occupancy_rho_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">occupancy_std</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">stats</span>
</div>
<div class="viewcode-block" id="Density.export3D"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Density.export3D">[docs]</a>    <span class="k">def</span> <span class="nf">export3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">site_labels</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export pdb and psf file of site centres for interactive visualization.</span>

<span class="sd">        &gt;&gt;&gt; density.export3D()</span>

<span class="sd">        :Arguments:</span>
<span class="sd">        filename     prefix for output files: </span>
<span class="sd">                     &lt;filename&gt;.psf, &lt;filename&gt;.pdb, and &lt;filename&gt;.vmd</span>
<span class="sd">        site_labels  selects sites (See site_labels())  </span>

<span class="sd">        The method writes a psf and a pdb file from the site map,</span>
<span class="sd">        suitable for visualization in, for instance, VMD. In addition,</span>
<span class="sd">        a VMD tcl file is produced. When it is sourced in VMD then the</span>
<span class="sd">        psf and pdb are loaded and site labels are shown next to the sites.</span>

<span class="sd">        Sites are represented as residues of resname &#39;NOD&#39;; each site</span>
<span class="sd">        is marked by one &#39;ATOM&#39; (of type CA) at the center of geometry</span>
<span class="sd">        of the site.</span>

<span class="sd">        Bulk and interstitial are always filtered from the list of</span>
<span class="sd">        sites because they do not have a well defined center.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;site_properties&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;Requires site_properties &#39;</span><span class="p">)</span>

        <span class="n">site_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">site_labels</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">,</span><span class="s">&#39;bulk&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_write_psf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">)</span>       <span class="c"># atoms are numbered consecutively...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_pdb</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">)</span>       <span class="c"># ..and residues correspond to sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_vmd</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">)</span>       <span class="c"># tcl code for labels in VMD</span>
</div>
    <span class="k">def</span> <span class="nf">_write_pdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">Bio.PDB</span>          <span class="c"># alternatively could use MDAnalysis, too, I guess</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">PDB</span><span class="o">.</span><span class="n">StructureBuilder</span><span class="o">.</span><span class="n">StructureBuilder</span><span class="p">()</span>
        <span class="n">B</span><span class="o">.</span><span class="n">init_structure</span><span class="p">(</span><span class="s">&#39;sites&#39;</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">init_model</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">init_seg</span><span class="p">(</span><span class="s">&#39;SITE&#39;</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">init_chain</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
        <span class="c"># note that empty fields MUST be written as a blank &#39; &#39; (ie a single space)</span>
        <span class="c"># or they are interpreted as altLoc specifiers named &#39;&#39; (weird...)</span>
        <span class="c"># ATOM numbering is done consecutively here and in write_psf() and</span>
        <span class="c"># there is only a single atom per residue.</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">site_labels</span><span class="p">:</span>   <span class="c"># node is the label==resid and it must be an integer</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span>              
            <span class="n">occ</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">occupancy_avg</span>       
            <span class="n">commonlabel</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">equivalence_name</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">commonlabel</span><span class="p">:</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">aname</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span>     <span class="c"># equiv/Common</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="mf">0.0</span> 
                <span class="n">aname</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span>     <span class="c"># single site</span>
            <span class="n">pdb_occupancy</span> <span class="o">=</span> <span class="n">occ</span>    <span class="c"># this should be customizable and selected from</span>
            <span class="n">pdb_beta</span> <span class="o">=</span> <span class="n">identity</span>    <span class="c"># volume, occupancy, degree, identity</span>
            <span class="n">B</span><span class="o">.</span><span class="n">init_residue</span><span class="p">(</span><span class="s">&#39;SIT&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">)</span> <span class="c"># choose same identifiers as in write_psf</span>
            <span class="n">B</span><span class="o">.</span><span class="n">init_atom</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">pdb_beta</span><span class="p">,</span><span class="n">pdb_occupancy</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;OH&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s">&#39;O&#39;</span><span class="p">)</span>
        <span class="n">io</span><span class="o">=</span><span class="n">Bio</span><span class="o">.</span><span class="n">PDB</span><span class="o">.</span><span class="n">PDBIO</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">get_structure</span><span class="p">()</span>
        <span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">pdbfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;pdb&#39;</span><span class="p">)</span>        
        <span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">pdbfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pseudo psf with nodes as atoms and edges as bonds&quot;&quot;&quot;</span>
        <span class="c"># Standard no CHEQ format for a Charmm PSF file:</span>
        <span class="n">psf_ATOM_format</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%(iatom)8d</span><span class="s"> </span><span class="si">%(segid)4s</span><span class="s"> </span><span class="si">%(resid)-4d</span><span class="s"> </span><span class="si">%(resname)4s</span><span class="s"> &#39;</span><span class="o">+</span>\
                          <span class="s">&#39;</span><span class="si">%(name)-4s</span><span class="s"> </span><span class="si">%(type)4s</span><span class="s"> </span><span class="si">%(charge)-14.6f%(mass)-14.4f%(imove)8d</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="n">psffilename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;psf&#39;</span><span class="p">)</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">psffilename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;PSF</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%7d</span><span class="s"> !NTITLE</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;* Sites written by</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">+</span>\
                  <span class="s">&#39;* $Id$</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>

        <span class="c"># ATOMS</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%6d</span><span class="s"> !NATOM</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_labels</span><span class="p">))</span>
        <span class="n">segid</span> <span class="o">=</span> <span class="s">&#39;SITE&#39;</span>     <span class="c"># choose the same identifiers as in pdb</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="s">&#39;SIT&#39;</span>    <span class="c"># choose the same identifiers as in pdb</span>
        <span class="n">atype</span> <span class="o">=</span> <span class="s">&#39;OH&#39;</span>       <span class="c"># choose the same identifiers as in pdb</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">imove</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c"># no fixed &#39;atoms&#39;</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">for</span> <span class="n">iatom</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">site_labels</span><span class="p">):</span>
            <span class="c"># atom numbering starts at 1, so iatom+1</span>
            <span class="n">iatom</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">commonlabel</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">equivalence_name</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">commonlabel</span><span class="p">:</span>
                <span class="n">aname</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span>     <span class="c"># equiv/Common    same as in pdb</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aname</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span>     <span class="c"># single site                </span>
            <span class="n">psf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">psf_ATOM_format</span> <span class="o">%</span> 
                      <span class="p">{</span><span class="s">&#39;iatom&#39;</span><span class="p">:</span><span class="n">iatom</span><span class="p">,</span> <span class="s">&#39;segid&#39;</span><span class="p">:</span><span class="n">segid</span><span class="p">,</span> <span class="s">&#39;resid&#39;</span><span class="p">:</span><span class="n">node</span><span class="p">,</span>
                       <span class="s">&#39;resname&#39;</span><span class="p">:</span><span class="n">resname</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">:</span><span class="n">aname</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span><span class="n">atype</span><span class="p">,</span>
                       <span class="s">&#39;charge&#39;</span><span class="p">:</span><span class="n">charge</span><span class="p">,</span> <span class="s">&#39;mass&#39;</span><span class="p">:</span><span class="n">mass</span><span class="p">,</span><span class="s">&#39;imove&#39;</span><span class="p">:</span><span class="n">imove</span><span class="p">}</span> <span class="p">)</span>        
        <span class="c"># ignore all the other sections (don&#39;t make sense anyway)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_vmd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">site_labels</span><span class="p">):</span>
        <span class="n">vmdfilename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;vmd&#39;</span><span class="p">)</span>
        <span class="n">PSF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;psf&#39;</span><span class="p">)</span>    <span class="c"># regenerate filenames ....</span>
        <span class="n">PDB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;pdb&#39;</span><span class="p">)</span>    <span class="c"># ... quick and dirty</span>
        <span class="n">vmd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">vmdfilename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">vmd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;mol new </span><span class="si">%(PSF)s</span><span class="s"> type psf first 0 last -1 step 1 filebonds 1 autobonds 0 waitfor all</span><span class="se">\n</span><span class="s">&quot;</span>
                  <span class="s">&quot;mol addfile </span><span class="si">%(PDB)s</span><span class="s"> type pdb first 0 last -1 step 1 filebonds 0 autobonds 0 waitfor all</span><span class="se">\n</span><span class="s">&quot;</span>\
                  <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="n">vmd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;proc labelsites {} {</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">site_labels</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">])</span> <span class="c"># shift a little bit</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">equivalence_name</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>    <span class="c"># if poossible, use a equivalence name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
               <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>               <span class="c"># .. otherwise use site label</span>
            <span class="n">vmd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">lappend sitelabels [draw text {</span><span class="si">%8.3f</span><span class="s"> </span><span class="si">%8.3f</span><span class="s"> </span><span class="si">%8.3f</span><span class="s">} &quot;</span><span class="si">%s</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="p">))</span>
        <span class="n">vmd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&quot;&quot;}</span>
<span class="s">proc delsitelabels {} {</span>
<span class="se">\t</span><span class="s">foreach id $sitelabels {</span>
<span class="se">\t\t</span><span class="s">draw delete $id</span>
<span class="se">\t</span><span class="s">}</span>
<span class="s">}</span>

<span class="s">mol delrep 0 top</span>
<span class="s">mol representation CPK 1.000000 0.300000 8.000000 6.000000</span>
<span class="s">mol color Name</span>
<span class="s">mol selection {all}</span>
<span class="s">mol material Opaque</span>
<span class="s">mol addrep top</span>

<span class="s">display projection orthographic</span>
<span class="s">axes location off</span>
<span class="s">color Display Background white</span>

<span class="s"># draw labels</span>
<span class="s">label textsize 1.0</span>
<span class="s">draw color black</span>
<span class="s">labelsites</span>
<span class="s">puts &quot;Labels can be deleted with &#39;delsitelabels&#39;.&quot;</span>
<span class="s">&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">vmd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        

    <span class="k">def</span> <span class="nf">_check_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span><span class="ne">AttributeError</span><span class="p">,</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The map has not been generated. Run map_sites() first.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connect nodes that are in each others&#39; first shell. Excludes cells that</span>
<span class="sd">        are not connected to any other cells, i.e. isolated cells will be counted</span>
<span class="sd">        as interstitial if MINsite &gt; 1.</span>

<span class="sd">        make_graph()</span>

<span class="sd">        Populates Density.graph with nodes (cell coordinates) and</span>
<span class="sd">        edges (tuples of nodes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Currently excludes cells that are not connected to any other</span>
        <span class="c"># cells. THIS MAY HAVE TO BE CHANGED (add [0,0,0] to __delta_ and</span>
        <span class="c"># also check export_map()).</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>      <span class="c"># nodes are indices (x,y,z) in map/grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;density&#39;</span>  <span class="c"># graph.info() ...</span>

        <span class="c"># site index list:</span>
        <span class="c"># [[x1,x2,...],[y1,y2,...],[z1,z2,...]] array of indices --&gt;</span>
        <span class="c"># belonging to sites (x1,y1,z1), (...)</span>
        <span class="n">sidx</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span>
                   <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">sidx</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>          <span class="c"># comes sorted but just make sure (important!)</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sidx</span><span class="p">:</span>    <span class="c"># TODO: Optimize these loops!</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shell</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">neighbour</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">pass</span>     <span class="c"># neighbour outside grid (probably should pad map)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;MINsite&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">sidx</span><span class="p">)</span>  <span class="c"># include ALL high-density regions</span>

        
    <span class="k">def</span> <span class="nf">_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">site</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list of indices of neighbour cells in the (+,+,+) octant</span>

<span class="sd">        This will exhaust all cells because the site index list is</span>
<span class="sd">        sorted in the same direction, ie we are looking for edges in</span>
<span class="sd">        the &#39;forward&#39; direction.</span>

<span class="sd">        Note:</span>
<span class="sd">        * The site itself is excluded from the neighbours. </span>
<span class="sd">        * Periodic boundary conditions have NOT been taken care off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">site</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delta_first_octant__</span><span class="p">)</span>  <span class="c"># site must be a tuple</span>

    <span class="k">def</span> <span class="nf">_label_connected_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;finds all connected subgraphs, sorts the m by size (largest</span>
<span class="sd">        first), and labels the cells in the map by the rank of the</span>
<span class="sd">        corresponding subgraph</span>

<span class="sd">        The interstitial has label &#39;0&#39;, the largest connected subgraph</span>
<span class="sd">        has &#39;1&#39; etc. The sites (i.e.the list of indices into map/grid)</span>
<span class="sd">        can be accesed as Density.site[label].</span>

<span class="sd">        Note that ISOLATED GRID CELLS do not show up as connected</span>
<span class="sd">        components and are also zeroed out in the map: they are</span>
<span class="sd">        COUNTED AS INTERSTITIAL. (One could change this by initially</span>
<span class="sd">        marking up the map with -1 and then looking for the -1 at the</span>
<span class="sd">        end of this function.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">NX</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>  <span class="c"># this does the hard work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">],[])</span>   <span class="c"># placeholder for interstitial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_draw_map_from_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Label cells in the map based on the site list.</span>

<span class="sd">        _draw_map_from_sites()</span>

<span class="sd">        Note that later sites (higher label) overwrite earlier</span>
<span class="sd">        sites. This is only important if the site list was manually</span>
<span class="sd">        manipulated and some sites actually overlap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># start with clean map (if MINsite&gt;1 then isolated density becomes interstitial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">sidx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sidx</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_annotate_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of properties associated with each site. Overwrites previous site_properties.&quot;&quot;&quot;</span>
        <span class="c"># make sure that this also includes equivalence sites and their sub-sites</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">occ_avg</span><span class="p">,</span><span class="n">occ_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_occupancies</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">equivalence_label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">equivalence_site</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>       <span class="c"># link to &#39;equivalence_site&#39;, see find_equivalence_sites_with()</span>
        <span class="c">##equivalence_name = [&#39; &#39;*10] * len(labels)  # fieldwidth 10</span>
        <span class="n">equivalence_name</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>    <span class="c"># want any-length strings</span>
        <span class="n">empty_centers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>       <span class="c"># workaround to get an &#39;object&#39; record</span>
        <span class="c"># Define and initialize the important data structure &#39;site_properties&#39;.</span>
        <span class="c"># See also find_equivalent_sites_with()        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span>
            <span class="n">labels</span><span class="p">,</span>                      <span class="c"># site number (id)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_site_volumes</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span>  <span class="c"># volume</span>
            <span class="n">occ_avg</span><span class="p">,</span><span class="n">occ_std</span><span class="p">,</span>             <span class="c"># occupancy: avg,stdev</span>
            <span class="n">empty_centers</span><span class="p">,</span>               <span class="c"># geometric centre</span>
            <span class="n">equivalence_label</span><span class="p">,</span>           <span class="c"># new label given to an equivalence site</span>
            <span class="n">equivalence_site</span><span class="p">,</span>            <span class="c"># label (int) of the equivalence site that contains this site</span>
            <span class="n">equivalence_name</span><span class="p">,</span>            <span class="c"># string representation of the label</span>
            <span class="p">],</span>
            <span class="n">names</span><span class="o">=</span><span class="s">&#39;label,volume,occupancy_avg,occupancy_std,center,equivalence_label,equivalence_site,equivalence_name&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">center</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_centers</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>  <span class="c"># now fill with 3-arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="o">.</span><span class="n">equivalence_name</span><span class="p">[:]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                                                    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; bins&#39;</span><span class="p">,]</span>  <span class="c"># always available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s">&#39;default filename &quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">())</span><span class="o">+</span><span class="s">&#39;&quot;&#39;</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nsites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nsites</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; sites&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nequivsites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalent_sites_index</span><span class="p">)</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;including &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nequivsites</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; equivalence sites&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="s">&#39;&lt;hop.sitemap.Density density with &#39;</span><span class="o">+</span><span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">features</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>

</div>
<div class="viewcode-block" id="remap_density"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.remap_density">[docs]</a><span class="k">def</span> <span class="nf">remap_density</span><span class="p">(</span><span class="n">density</span><span class="p">,</span><span class="n">ref</span><span class="p">,</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform a Density object to a grid given by a reference Density.</span>

<span class="sd">    &gt;&gt;&gt; newdensity = remap_density(old,ref)</span>

<span class="sd">    The user is repsonsible to guarantee that:</span>
<span class="sd">    * the grid spacing is the same in both densities</span>
<span class="sd">    * the grids only differ by a translation, not a rotation</span>

<span class="sd">    :Arguments:</span>
<span class="sd">    old          Density object with site map</span>
<span class="sd">    ref          reference Density object that provides the new grid shape</span>
<span class="sd">    verbosity=0  increase to up to 3 for status and diagnostic messages</span>

<span class="sd">    :Returns:</span>
<span class="sd">    newdensity   Density object with old&#39;s density and site map transformed</span>
<span class="sd">                 to ref&#39;s coordinate system. It is now possible to manipulate</span>
<span class="sd">                 newdensity&#39;s and ref&#39;s arrays (grid and map) together, e.g.</span>

<span class="sd">                 &gt;&gt;&gt; common = (newdensity.map &gt; 1 &amp; ref.map &gt; 1)</span>
<span class="sd">                 &gt;&gt;&gt; pairs = newdensity.map[common], ref.map[common]</span>

<span class="sd">    Note that this function is not well implemented at the moment and</span>
<span class="sd">    can take a considerable amount of time on bigger grids</span>
<span class="sd">    (100x100x100 take about 3 Min).</span>

<span class="sd">    An implicit assumption is that the two coordinate systems for the</span>
<span class="sd">    two grids are parallel and are only offset by a translation. This</span>
<span class="sd">    cannot be checked based on the available data and must be</span>
<span class="sd">    guaranteed by the user. RMS-fitting the trajectories is sufficient</span>
<span class="sd">    for this to hold.</span>

<span class="sd">    BUGS:</span>

<span class="sd">    * This is not a good way to do the remapping: It requires parallel</span>
<span class="sd">      coordinate systems and the exact same delta.</span>
<span class="sd">    * It is slow.</span>
<span class="sd">    * It would be much better to interpolate density on the reference grid,    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>  <span class="c"># set to 0 for no messages</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">map</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">density</span><span class="o">.</span><span class="n">map</span>
        <span class="n">density</span><span class="o">.</span><span class="n">grid</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Both density and ref need to be proper Density objects&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">delta</span> <span class="o">-</span> <span class="n">density</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;The grid spacings are not the same; this is probably WRONG.&#39;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">InconsistentDataWarning</span><span class="p">)</span>
    
    <span class="n">D</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
    <span class="n">newgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">newmap</span> <span class="o">=</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;interstitial&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c"># lookup table for index transformation: i,j,k |--&gt; i&#39;,j&#39;,k&#39; = t(i,j,k)</span>
    <span class="c"># (instead of a linear transformation; also makes it easier to flag outliers)</span>
    <span class="n">t_table</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span><span class="n">ref</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> \
                            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">D</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>    <span class="c"># mark outliers with -1 (and filter in transformed())</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">t_table</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">ref</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="n">ijk</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns transformed index triplett or None if out of bounds or no input.</span>
<span class="sd">        &gt;&gt;&gt; i&#39;,j&#39;,k&#39; = transformed((3,4,5))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ijk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>     <span class="c"># called on empty site</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">t_table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">t_table</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">t_table</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">ijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>   
            <span class="k">return</span> <span class="bp">None</span>     <span class="c"># outside the table</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># only return indices that are in bounds (outliers == -1)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span>

    <span class="c"># Remap the density (moderately fast but not great):</span>
    <span class="c"># pre-compute pairs (ijk,t(ijk)), only if t(ijk) != None then assign all at once</span>
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Transforming </span><span class="si">%d</span><span class="s"> indices...</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">numpy</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c"># TODO OPTIMIZE: </span>
    <span class="c"># next line is a bottleneck and takes long (the if-part is not the problem)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">ijk</span><span class="p">,</span> <span class="n">transformed</span><span class="p">(</span><span class="n">ijk</span><span class="p">))</span> \
            <span class="k">for</span> <span class="n">ijk</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">transformed</span><span class="p">(</span><span class="n">ijk</span><span class="p">)])</span>
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Remapping the density old --&gt; new...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="n">newgrid</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>

    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Remapping the site list...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="n">newsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_tuplelist</span><span class="p">([</span><span class="n">transformed</span><span class="p">(</span><span class="n">ijk</span><span class="p">)</span> <span class="k">for</span> <span class="n">ijk</span> <span class="ow">in</span> <span class="n">site</span><span class="p">])</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">density</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>
    <span class="c">#DensityClass = type(density)     # can be Density or PDBDensity</span>
    <span class="n">DensityClass</span> <span class="o">=</span> <span class="n">hop</span><span class="o">.</span><span class="n">sitemap</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">density</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="n">newdensity</span> <span class="o">=</span> <span class="n">DensityClass</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">newgrid</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">edges</span><span class="p">[:],</span>
                         <span class="n">parameters</span><span class="o">=</span><span class="n">density</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                         <span class="n">unit</span><span class="o">=</span><span class="n">density</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">metadata</span><span class="o">=</span><span class="n">density</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;_xray2psf&#39;</span><span class="p">,</span><span class="s">&#39;_psf2xray&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># add xray2psf translation table if it is a PDBDensity</span>
            <span class="n">newdensity</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="n">density</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="n">newdensity</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">newsites</span>       <span class="c"># hack in new sites instead of calc. from density</span>
    <span class="n">newdensity</span><span class="o">.</span><span class="n">_draw_map_from_sites</span><span class="p">()</span> <span class="c"># build map from transformed sites</span>
    <span class="n">newdensity</span><span class="o">.</span><span class="n">_annotate_sites</span><span class="p">()</span>      <span class="c"># recalculate site props, esp. centers</span>
    <span class="n">newdensity</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;remapped_source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
    <span class="n">newdensity</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="s">&#39;remapped_reference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newdensity</span>
</div>
<div class="viewcode-block" id="unique_tuplelist"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.unique_tuplelist">[docs]</a><span class="k">def</span> <span class="nf">unique_tuplelist</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort a list of tuples and remove all values None&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>  <span class="c"># must pre-allocate to keep dtype</span>
    <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">x</span>                                     <span class="c"># array with tuples as entries</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>          <span class="c"># None sorts into first position</span>
        <span class="n">takefirst</span> <span class="o">=</span> <span class="bp">False</span>       <span class="c"># hack to eliminate None from result</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">takefirst</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">takefirst</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">!=</span><span class="n">tmp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c"># remove duplicates</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>    <span class="c"># here we want a list</span>
    </div>
<div class="viewcode-block" id="find_common_sites"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.find_common_sites">[docs]</a><span class="k">def</span> <span class="nf">find_common_sites</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">use_equivalencesites</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find sites that overlap in space in Density a and b.</span>

<span class="sd">    m = find_common_sites(a,b)</span>

<span class="sd">    :Arguments:</span>
<span class="sd">    a        Density instance</span>
<span class="sd">    b        Density instance</span>

<span class="sd">    :Returns:</span>
<span class="sd">    array of mappings between sites in a and b that overlap</span>
<span class="sd">    m[:,0]     site labels in a</span>
<span class="sd">    m[:,1]     site labels in b</span>
<span class="sd">    dict(m)    translates labels in a to labels in b</span>
<span class="sd">    dict(m[:,[1,0]])</span>
<span class="sd">               translates labels in b to labels in a</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;a and b are not defined on the same grid: use remap_density()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> \
                              <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="p">))]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;a and b do not superimpose in space (different edges)&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Both densities need to be proper Density objects with map and edges attributes.&#39;</span><span class="p">)</span>

    <span class="c"># make a list of sites that appear in the same position and are not bulk</span>
    <span class="n">common</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">])</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">common</span><span class="p">],</span><span class="n">b</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">common</span><span class="p">]])</span> <span class="c"># multiple entries == overlap vol</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>     <span class="c"># remove multiple entries</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[],[]])</span>                   <span class="c"># return empty mapping</span>
    <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="find_overlap_coeff"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.find_overlap_coeff">[docs]</a><span class="k">def</span> <span class="nf">find_overlap_coeff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find sites that overlap in space in Density a and b.</span>
<span class="sd">    </span>
<span class="sd">    m = find_overlap_coeff(a,b)</span>
<span class="sd">	</span>
<span class="sd">    :Arguments:</span>
<span class="sd">    a        Density instance</span>
<span class="sd">    b        Density instance</span>

<span class="sd">    :Returns:</span>
<span class="sd">    array sites in a and b that overlap</span>
<span class="sd">       and array of probability of overlap for overlapped sites</span>
<span class="sd">    m[:,0]     site labels in a</span>
<span class="sd">    m[:,1]     site labels in b</span>
<span class="sd">    oc         amount of overlap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#### liz hack to beautiful code</span>
    <span class="n">common</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">])</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">common</span><span class="p">],</span><span class="n">b</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">common</span><span class="p">]])</span> <span class="c"># multiple entries == overlap vol</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>     <span class="c"># remove multiple entries</span>
    <span class="n">oc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">isite</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    	<span class="n">coeff</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="c">#a_cellvol = a.delta[0][0]*a.delta[1][1]*a.delta[2][2]  # calc vol of grid cell for a</span>
	<span class="c">#b_cellvol = b.delta[0][0]*b.delta[1][1]*b.delta[2][2]  # calc vol of grid cell for b</span>
	<span class="n">sum_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
	<span class="n">sum_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">map</span> <span class="o">&gt;</span> <span class="n">SITELABEL</span><span class="p">[</span><span class="s">&#39;bulk&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
	<span class="c">#f_a = hop.constants.get_conversion_factor(&#39;density&#39;, a.unit[&#39;length&#39;], a.unit[&#39;density&#39;])</span>
	<span class="c">#f_b = hop.constants.get_conversion_factor(&#39;density&#39;, b.unit[&#39;length&#39;], b.unit[&#39;density&#39;])</span>
	<span class="c">#a_bulk_density = (a.site_occupancy()[1][0]/a.site_volume()[1][0]) * f_a</span>
	<span class="c">#b_bulk_density = (b.site_occupancy()[1][0]/b.site_volume()[1][0]) * f_b</span>
	<span class="c">#print a_cellvol, b_cellvol</span>
    	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
			<span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
				<span class="c">#print a.grid[j], b.grid[k],j,i[0],i[1], a_bulk_density, b_bulk_density</span>
				<span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
					<span class="c"># density of grid cell point normalized to bulk density in a single grid cell</span>
					<span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">sum_a</span><span class="p">)</span> <span class="c">#/a_bulk_density)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">sum_b</span><span class="p">)</span> <span class="c">#b_bulk_density)</span>
    	<span class="n">oc</span><span class="p">[</span><span class="n">isite</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span> 
    <span class="k">return</span> <span class="n">oc</span> 
</div>
<span class="k">def</span> <span class="nf">density_from_dcd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;density_from_dcd() is deprecated and will be removed. &quot;</span>
                  <span class="s">&quot;Use density_from_trajectory().&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">density_from_trajectory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="density_from_trajectory"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.density_from_trajectory">[docs]</a><span class="k">def</span> <span class="nf">density_from_trajectory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density grid from a trajectory.</span>

<span class="sd">       density_from_trajectory(PSF, DCD, delta=1.0, atomselection=&#39;name OH2&#39;, ...) --&gt; density</span>

<span class="sd">    or</span>

<span class="sd">       density_from_trajectory(PDB, XTC, delta=1.0, atomselection=&#39;name OH2&#39;, ...) --&gt; density</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      psf/pdb/gro     </span>
<span class="sd">            topology file </span>
<span class="sd">      dcd/xtc/trr/pdb</span>
<span class="sd">            trajectory; if reading a single PDB file it is sufficient to just provide it</span>
<span class="sd">            once as a single argument</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      atomselection</span>
<span class="sd">            selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">            [&quot;name OH2&quot;]</span>
<span class="sd">      delta</span>
<span class="sd">            approximate bin size for the density grid in Angstroem (same in x,y,z)</span>
<span class="sd">            (It is slightly adjusted when the box length is not an integer multiple</span>
<span class="sd">            of delta.) [1.0]</span>
<span class="sd">      metadata</span>
<span class="sd">            dictionary of additional data to be saved with the object</span>
<span class="sd">      padding </span>
<span class="sd">            increase histogram dimensions by padding (on top of initial box size)</span>
<span class="sd">            in Angstroem [2.0]</span>
<span class="sd">      soluteselection</span>
<span class="sd">            MDAnalysis selection for the solute, e.g. &quot;protein&quot; [``None``]</span>
<span class="sd">      cutoff  </span>
<span class="sd">            With *cutoff*, select &#39;&lt;atomsel&gt; NOT WITHIN &lt;cutoff&gt; OF &lt;soluteselection&gt;&#39;</span>
<span class="sd">            (Special routines that are faster than the standard AROUND selection) [0]</span>
<span class="sd">      verbosity: int  </span>
<span class="sd">            level of chattiness; 0 is silent, 3 is verbose [3]</span>
<span class="sd">    </span>
<span class="sd">    :Returns: :class:`hop.sitemap.Density`</span>

<span class="sd">    :TODO:</span>
<span class="sd">      * Should be able to also set skip and start/stop for data collection.</span>

<span class="sd">    .. Note::</span>
<span class="sd">        * In order to calculate the bulk density, use</span>

<span class="sd">              atomselection=&#39;name OH2&#39;,soluteselection=&#39;protein and not name H*&#39;,cutoff=3.5</span>
<span class="sd">  </span>
<span class="sd">          This will select water oxygens not within 3.5 A of the protein heavy atoms.</span>
<span class="sd">          Alternatively, use the VMD-based  :func:`density_from_volmap` function.</span>
<span class="sd">        * The histogramming grid is determined by the initial frames min and max.</span>
<span class="sd">        * metadata will be populated with psf, dcd, and a few other items.</span>
<span class="sd">          This allows more compact downstream processing.</span>

<span class="sd">    .. SeeAlso:: docs for :func:`density_from_Universe` (defaults for kwargs are defined there).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">MDAnalysis</span>
    <span class="k">return</span> <span class="n">density_from_Universe</span><span class="p">(</span><span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="density_from_Universe"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.density_from_Universe">[docs]</a><span class="k">def</span> <span class="nf">density_from_Universe</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">atomselection</span><span class="o">=</span><span class="s">&#39;name OH2&#39;</span><span class="p">,</span>
                          <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">padding</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">soluteselection</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                          <span class="n">use_kdtree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density grid from a MDAnalysis.Universe object.</span>

<span class="sd">      density_from_dcd(universe, delta=1.0, atomselection=&#39;name OH2&#39;, ...) --&gt; density</span>
<span class="sd">   </span>
<span class="sd">    :Arguments:</span>
<span class="sd">      universe</span>
<span class="sd">            :class:`MDAnalysis.Universe` object with a trajectory   </span>

<span class="sd">    :Keywords:</span>
<span class="sd">      atomselection</span>
<span class="sd">            selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">            [&quot;name OH2&quot;]</span>
<span class="sd">      delta</span>
<span class="sd">            approximate bin size for the density grid in Angstroem (same in x,y,z)</span>
<span class="sd">            (It is slightly adjusted when the box length is not an integer multiple</span>
<span class="sd">            of delta.) [1.0]</span>
<span class="sd">      metadata</span>
<span class="sd">            dictionary of additional data to be saved with the object</span>
<span class="sd">      padding </span>
<span class="sd">            increase histogram dimensions by padding (on top of initial box size)</span>
<span class="sd">            in Angstroem [2.0]</span>
<span class="sd">      soluteselection</span>
<span class="sd">            MDAnalysis selection for the solute, e.g. &quot;protein&quot; [``None``]</span>
<span class="sd">      cutoff  </span>
<span class="sd">            With *cutoff*, select &#39;&lt;atomsel&gt; NOT WITHIN &lt;cutoff&gt; OF &lt;soluteselection&gt;&#39;</span>
<span class="sd">            (Special routines that are faster than the standard AROUND selection) [0]</span>
<span class="sd">      verbosity: int  </span>
<span class="sd">            level of chattiness; 0 is silent, 3 is verbose [3]</span>
<span class="sd">      parameters  </span>
<span class="sd">            dict with some special parameters for :class:`~hop.sitemap.Density` (see doc)          </span>
<span class="sd">      kwargs  </span>
<span class="sd">            metadata, parameters are modified and passed on to :class:`~hop.sitemap.Density`</span>
<span class="sd">    </span>
<span class="sd">    :Returns: :class:`hop.sitemap.Density`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;The universe must be a proper MDAnalysis.Universe instance.&quot;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">soluteselection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># special fast selection for &#39;&lt;atomsel&gt; not within &lt;cutoff&gt; of &lt;solutesel&gt;&#39;</span>
        <span class="n">notwithin_coordinates</span> <span class="o">=</span> <span class="n">notwithin_coordinates_factory</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">atomselection</span><span class="p">,</span><span class="n">soluteselection</span><span class="p">,</span><span class="n">cutoff</span><span class="p">,</span><span class="n">use_kdtree</span><span class="o">=</span><span class="n">use_kdtree</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">current_coordinates</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">notwithin_coordinates</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">current_coordinates</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    
    <span class="n">coord</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">()</span>
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Selected </span><span class="si">%d</span><span class="s"> atoms out of </span><span class="si">%d</span><span class="s"> atoms (</span><span class="si">%s</span><span class="s">) from </span><span class="si">%d</span><span class="s"> total.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span>
        <span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)),</span><span class="n">atomselection</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>

    <span class="c"># mild warning; typically this is run on RMS-fitted trajectories and</span>
    <span class="c"># so the box information is rather meaningless</span>
    <span class="n">box</span><span class="p">,</span><span class="n">angles</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>    
    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="p">(</span><span class="mf">90.</span><span class="p">,</span><span class="mf">90.</span><span class="p">,</span><span class="mf">90.</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Non-orthorhombic unit-cell --- make sure that it has been remapped properly!&quot;</span><span class="p">)</span>

    <span class="c"># Make the box bigger to avoid as much as possible &#39;outlier&#39;. This</span>
    <span class="c"># is important if the sites are defined at a high density: in this</span>
    <span class="c"># case the bulk regions don&#39;t have to be close to 1 * n0 but can</span>
    <span class="c"># be less. It&#39;s much more difficult to deal with outliers.  The</span>
    <span class="c"># ideal solution would use images: implement &#39;looking across the</span>
    <span class="c"># periodic boundaries&#39; but that gets complicate when the box</span>
    <span class="c"># rotates due to RMS fitting.</span>
    <span class="n">smin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span>
    <span class="n">smax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span>

    <span class="n">BINS</span> <span class="o">=</span> <span class="n">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>    
    <span class="n">arange</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">BINS</span><span class="p">[</span><span class="s">&#39;min&#39;</span><span class="p">],</span><span class="n">BINS</span><span class="p">[</span><span class="s">&#39;max&#39;</span><span class="p">])</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">BINS</span><span class="p">[</span><span class="s">&#39;Nbins&#39;</span><span class="p">]</span>

    <span class="c"># create empty grid with the right dimensions (and get the edges)</span>
    <span class="n">grid</span><span class="p">,</span><span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span><span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">*=</span> <span class="mf">0.0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Histograming </span><span class="si">%6d</span><span class="s"> atoms in frame </span><span class="si">%5d</span><span class="s">/</span><span class="si">%d</span><span class="s">  [</span><span class="si">%5.1f%%</span><span class="s">]</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span><span class="mf">100.0</span><span class="o">*</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">))</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">h</span><span class="p">[:],</span><span class="n">edges</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="n">h</span>  <span class="c"># accumulate average histogram</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">skip</span>
    <span class="n">grid</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>

    <span class="c"># pick from kwargs</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;metadata&#39;</span><span class="p">,{})</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;psf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">filename</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dcd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;atomselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomselection</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;n_frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_frames</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;totaltime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">skip_timestep</span> \
                                  <span class="o">*</span> <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;AKMA&#39;</span><span class="p">,</span><span class="s">&#39;ps&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">skip_timestep</span> <span class="o">*</span> \
                     <span class="n">hop</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="s">&#39;AKMA&#39;</span><span class="p">,</span><span class="s">&#39;ps&#39;</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;time_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ps&#39;</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dcd_skip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">skip_timestep</span>  <span class="c"># frames</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dcd_delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">delta</span>         <span class="c"># in AKMA</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">soluteselection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;soluteselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soluteselection</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff</span>             <span class="c"># in Angstrom</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;parameters&#39;</span><span class="p">,{})</span>
    <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>             <span class="c"># must override</span>

    <span class="c"># all other kwargs are discarded</span>

    <span class="c"># Density automatically converts histogram to density for isDensity=False</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Density</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">),</span>
                <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>    
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Histogram completed (density in Angstrom**-3)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">g</span>

</div>
<div class="viewcode-block" id="notwithin_coordinates_factory"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.notwithin_coordinates_factory">[docs]</a><span class="k">def</span> <span class="nf">notwithin_coordinates_factory</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="n">sel1</span><span class="p">,</span> <span class="n">sel2</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">not_within</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">use_kdtree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate optimized selection for &#39;*sel1* not within *cutoff* of *sel2*&#39;</span>

<span class="sd">    Example usage::</span>
<span class="sd">      notwithin_coordinates = notwithin_coordinates_factory(universe, &#39;name OH2&#39;,&#39;protein and not name H*&#39;,3.5)</span>
<span class="sd">      ...</span>
<span class="sd">      coord = notwithin_coordinates()        # changes with time step</span>
<span class="sd">      coord = notwithin_coordinates(cutoff2) # can use different cut off</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      not_within</span>
<span class="sd">         True: selection behaves as &#39;not within&#39; (As described above)</span>
<span class="sd">         False: selection is a &lt;sel1&gt; WITHIN &lt;cutoff&gt; OF &lt;sel2&gt;&#39;</span>
<span class="sd">      use_kdtree</span>
<span class="sd">         True: use fast kd-tree based selections (requires new MDAnalysis &gt;= 0.6)</span>
<span class="sd">         False: use distance matrix approach</span>

<span class="sd">    .. Note::</span>
<span class="sd">        * Periodic boundary conditions are NOT taken into account: the naive</span>
<span class="sd">          minimum image convention employed in the distance check is currently</span>
<span class="sd">          not being applied to remap the coordinates themselves, and hence it</span>
<span class="sd">          would lead to counts in the wrong region.</span>
<span class="sd">        * The selections are static and do not change with time steps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Benchmark of FABP system (solvent 3400 OH2, protein 2100 atoms) on G4 powerbook, 500 frames</span>
    <span class="c">#                    cpu/s    relative   speedup       use_kdtree</span>
    <span class="c"># distance matrix    633        1          1           False</span>
    <span class="c"># AROUND + kdtree    420        0.66       1.5         n/a (&#39;name OH2 around 4 protein&#39;)</span>
    <span class="c"># manual + kdtree    182        0.29       3.5         True</span>
    <span class="n">solvent</span> <span class="o">=</span> <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel1</span><span class="p">)</span>
    <span class="n">protein</span> <span class="o">=</span> <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_kdtree</span><span class="p">:</span>
        <span class="c"># using faster hand-coded &#39;not within&#39; selection with kd-tree</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.KDTree.NeighborSearch</span> <span class="kn">as</span> <span class="nn">NS</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.core.AtomGroup</span>
        <span class="n">set_solvent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>     <span class="c"># need sets to do bulk = allsolvent - selection</span>
        <span class="k">if</span> <span class="n">not_within</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>  <span class="c"># default</span>
            <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
                <span class="c"># must update every time step</span>
                <span class="n">ns_w</span> <span class="o">=</span> <span class="n">NS</span><span class="o">.</span><span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>  <span class="c"># build kd-tree on solvent (N_w &gt; N_protein)</span>
                <span class="n">solvation_shell</span> <span class="o">=</span> <span class="n">ns_w</span><span class="o">.</span><span class="n">search_list</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span><span class="n">cutoff</span><span class="p">)</span>  <span class="c"># solvent within CUTOFF of protein</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">(</span><span class="n">set_solvent</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">solvation_shell</span><span class="p">))</span> <span class="c"># bulk</span>
                <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
                <span class="c"># acts as &#39;&lt;solvent&gt; WITHIN &lt;cutoff&gt; OF &lt;protein&gt;&#39;</span>
                <span class="c"># must update every time step</span>
                <span class="n">ns_w</span> <span class="o">=</span> <span class="n">NS</span><span class="o">.</span><span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>  <span class="c"># build kd-tree on solvent (N_w &gt; N_protein)</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">ns_w</span><span class="o">.</span><span class="n">search_list</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span><span class="n">cutoff</span><span class="p">)</span>  <span class="c"># solvent within CUTOFF of protein</span>
                <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>            
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># slower distance matrix based (calculate all with all distances first)</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.core.distances</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">solvent</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">protein</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># as long as s_coor is not minimum-image remapped</span>
        <span class="k">if</span> <span class="n">not_within</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>   <span class="c"># default</span>
            <span class="n">compare</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">greater</span>
            <span class="n">aggregatefunc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compare</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">less_equal</span>
            <span class="n">aggregatefunc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span>
        <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
            <span class="n">s_coor</span> <span class="o">=</span> <span class="n">solvent</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
            <span class="n">p_coor</span> <span class="o">=</span> <span class="n">protein</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
            <span class="c"># Does water i satisfy d[i,j] &gt; r for ALL j?</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">s_coor</span><span class="p">,</span><span class="n">p_coor</span><span class="p">,</span><span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s_coor</span><span class="p">[</span><span class="n">aggregatefunc</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">cutoff</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">notwithin_coordinates</span>


</div>
<div class="viewcode-block" id="density_from_volmap"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.density_from_volmap">[docs]</a><span class="k">def</span> <span class="nf">density_from_volmap</span><span class="p">(</span><span class="n">psf</span><span class="p">,</span><span class="n">dcd</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">atomselection</span><span class="o">=</span><span class="s">&#39;name OH2&#39;</span><span class="p">,</span>
                        <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the density using VMD&#39;s VolMap plugin and an intermediate dx file.</span>

<span class="sd">    density_from_volmap(psf,dcd,dx,delta=1.0,atomselection=&#39;name OH2&#39;,</span>
<span class="sd">          metadata=dict(psf=psf,dcd=dcd,system=&#39;I-FABP apo&#39;)</span>

<span class="sd">    psf     Charmm psf topology file</span>
<span class="sd">    dcd     Charmm trajectory</span>
<span class="sd">    dx      dx file that holds the density generated by VolMap; if not provided a</span>
<span class="sd">            temporary file is created (and deleted)</span>
<span class="sd">    atomselection</span>
<span class="sd">            selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">    delta   approximate bin size for the density grid (same in x,y,z)</span>
<span class="sd">            (It is slightly adjusted when the box length is not an integer multiple</span>
<span class="sd">            of delta.)</span>
<span class="sd">    verbosity=int  level of chattiness; 0 is silent, 3 is verbose</span>

<span class="sd">    **kwargs   metadata and parameters are passed to Density(), everything else to VolMap</span>

<span class="sd">     Density args:</span>
<span class="sd">     metadata       dictionary of additional data to be saved with the object</span>
<span class="sd">     parameters     dict of special Density parameters (see Density() doc)</span>

<span class="sd">     VolMap args: </span>
<span class="sd">     load_new       True: load psf and dcd into VMD. False: use psf and dcd already</span>
<span class="sd">                   loaded into VMD (default is True)</span>
<span class="sd">    </span>
<span class="sd">    Returns a Density object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">hop.external</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>

    <span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>  <span class="c"># set to 0 for no messages</span>

    <span class="c"># pick Density parameters from kwargs</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;parameters&#39;</span><span class="p">,{})</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;metadata&#39;</span><span class="p">,{})</span>
    <span class="c"># ... everything else is VolMap args</span>

    <span class="n">remove_dx</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dx</span><span class="p">:</span>
        <span class="n">remove_dx</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">dxhandle</span><span class="p">,</span><span class="n">dx</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s">&#39;.dx&#39;</span><span class="p">)</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;Using tempororary dx file &quot;</span><span class="si">%s</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dx</span><span class="p">)</span>
        
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Connecting to VMD (ignore &#39;error: uncaptured python exception&#39;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="n">vmd</span> <span class="o">=</span> <span class="n">hop</span><span class="o">.</span><span class="n">external</span><span class="o">.</span><span class="n">VMD</span><span class="p">()</span>
    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;VolMap calculates the density. This takes a while...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="n">vmd</span><span class="o">.</span><span class="n">volmap</span><span class="p">(</span><span class="n">psf</span><span class="p">,</span><span class="n">dcd</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span><span class="n">atomselection</span><span class="o">=</span><span class="n">atomselection</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;psf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dcd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcd</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;vmd_dx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;atomselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomselection</span>

    <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;isDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>             <span class="c"># must override</span>

    <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Building density object from dx file &#39;</span><span class="si">%(dx)s</span><span class="s">&#39;...</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Density</span><span class="p">(</span><span class="n">dxfile</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">),</span>
                <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_dx</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="Bfactor2RMSF"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.Bfactor2RMSF">[docs]</a><span class="k">def</span> <span class="nf">Bfactor2RMSF</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Atomic root mean square fluctuation (in Angstrom) from the crystallographic B-factor</span>

<span class="sd">    B = [(8*PI**2)/3] * (RMSF)**2</span>

<span class="sd">    Willis &amp; Pryor, Thermal vibrations in crystallography, Cambridge</span>
<span class="sd">    Univ. Press, 1975</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">B</span><span class="o">/</span><span class="mf">8.</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
</div>
<div class="viewcode-block" id="PDBDensity"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity">[docs]</a><span class="k">class</span> <span class="nc">PDBDensity</span><span class="p">(</span><span class="n">Density</span><span class="p">):</span>
    <span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Density with additional information about original crystal structure.</span>

<span class="s">This is simply the Density class (see below) enhanced by the add_xray2psf(),</span>
<span class="s">W(), and Wequiv() methods.</span>

<span class="s">Note that later analysis often ignores the site with the bulknumber by default</span>
<span class="s">so one should (after computing a site map) also insert an empty bulk site:</span>

<span class="s">  # canonical way to build a PDBDensity</span>
<span class="s">  # (builds the sitepa at threshold and inserts a pseudo bulk site)</span>
<span class="s">  xray = BfactorDensityCreator(...).PDBDensity(threshold)</span>

<span class="s">  # rebuild site map</span>
<span class="s">  xray.map_sites(threshold) # map sites at density cutoff threshold</span>
<span class="s">  xray.site_insert_nobulk() # insert &#39;fake&#39; bulk site at position SITELABEL[&#39;bulk&#39;]</span>

<span class="s">  # find X-ray waters that correspond to a site in another density Y:</span>
<span class="s">  # (1) build the list of equivalence sites, using the x-ray density as reference</span>
<span class="s">  Y.find_equivalence_sites(xray)     # also updates equiv-sites in xray!</span>
<span class="s">  # (2) look at the matches in xray</span>
<span class="s">  xray.Wequiv()        TODO: not working yet</span>
<span class="s">  </span>

<span class="s">&quot;&quot;&quot;</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Density Class</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Density</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="c"># will probably break under multiple inheritance but I haven&#39;t figured out how to use super here</span>
    <span class="n">_saved_attributes</span> <span class="o">=</span> <span class="n">Density</span><span class="o">.</span><span class="n">_saved_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;_xray2psf&#39;</span><span class="p">,</span> <span class="s">&#39;_psf2xray&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="PDBDensity.add_xray2psf"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity.add_xray2psf">[docs]</a>    <span class="k">def</span> <span class="nf">add_xray2psf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pdbfile</span><span class="p">,</span><span class="n">regex</span><span class="o">=</span><span class="s">r&#39;\s*W\s*|HOH|WAT|.*TIP.*|.*SPC.*&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add translation table between sequential psf numbering and original pdb numbering for water.</span>

<span class="sd">        D.add_xray2psf(pdbfilename)</span>

<span class="sd">        The original pdb is read and all water molecules are sequentially mapped</span>
<span class="sd">        to the water molecules in the psf (without any checks). The pdb is read</span>
<span class="sd">        and analyzed using Bio.PDB.</span>

<span class="sd">        pdbfilename    Original crystallographic pdb file</span>
<span class="sd">        regex          extended regular expression to detect water   residues</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="kn">import</span> <span class="nn">Bio.PDB</span>
        <span class="n">water</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">PDB</span><span class="o">.</span><span class="n">PDBParser</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&#39;0UNK&#39;</span><span class="p">,</span><span class="n">pdbfile</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># number waters sequentially and store the pdb resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xray2psf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">resid_xray</span><span class="p">,</span><span class="n">resid_psf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">resid_psf</span><span class="p">,</span><span class="n">resid_xray</span> <span class="ow">in</span> 
                               <span class="nb">enumerate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_residues</span><span class="p">()</span> <span class="k">if</span> <span class="n">water</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">resname</span><span class="p">)])</span>
                               <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psf2xray</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">resid_psf</span><span class="p">,</span><span class="n">resid_xray</span><span class="p">)</span> <span class="k">for</span> <span class="n">resid_xray</span><span class="p">,</span><span class="n">resid_psf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xray2psf</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span></div>
    <span class="k">def</span> <span class="nf">_check_site_resid_match</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xray2psf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="s">&#39;sites&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="PDBDensity.W"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity.W">[docs]</a>    <span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">returntype</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the resid of water N. </span>

<span class="sd">        If returntype == &#39;psf&#39; then N is interpreted as the resid in the</span>
<span class="sd">        x-ray crystal structure (or original pdb file) and a resid N&#39; in the</span>
<span class="sd">        psf is returned.</span>

<span class="sd">        If returntype == &#39;xray&#39; then N is a resid in the psf and the</span>
<span class="sd">        corresponding crystal structure water is returned. This is</span>
<span class="sd">        useful to label water molecules by their published identifier,</span>
<span class="sd">        eg &#39;W128&#39;.</span>

<span class="sd">        If the returntype is set to &#39;auto&#39; and N starts with a W (eg</span>
<span class="sd">        &#39;W128&#39;) then it is assumed to be a crystal water and the</span>
<span class="sd">        returntype is automatically set to psf, otherwise it acts like</span>
<span class="sd">        &#39;xray&#39;.</span>
<span class="sd"> </span>
<span class="sd">        :Arguments:</span>
<span class="sd">        N              resid of molecule (can be an iterable)</span>
<span class="sd">        returntype     &#39;auto&#39; | &#39;psf&#39; | &#39;xray&#39;</span>
<span class="sd">        format         False: return a integer number</span>
<span class="sd">                       True: default string (either &quot;WN&#39;&quot; for x-ray or &quot;#N&#39;&quot; for psf)</span>
<span class="sd">                       python format string: if the string contains %(resid)d then the string</span>
<span class="sd">                                             will be used as a format, otherwise the bare number</span>
<span class="sd">                                             is returned without raising an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">returntype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;auto&quot;</span><span class="p">,</span><span class="s">&quot;psf&quot;</span><span class="p">,</span><span class="s">&quot;xray&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;returntype must be one of &#39;psf&#39; or &#39;xray&#39;&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_getN</span><span class="p">(</span><span class="n">_N</span><span class="p">,</span><span class="n">returntype</span><span class="o">=</span><span class="n">returntype</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">)</span> <span class="k">for</span> <span class="n">_N</span> <span class="ow">in</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="PDBDensity.Wequiv"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity.Wequiv">[docs]</a>    <span class="k">def</span> <span class="nf">Wequiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the PDB resids of the equivalent sites.</span>

<span class="sd">        array = Wequiv(format=True)</span>

<span class="sd">        format        True: array of identifiers &#39;Wnn&#39;</span>
<span class="sd">                      False: array of integers</span>
<span class="sd">                      string: python format string; %(resid)d is replaced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="s">&#39;subsites&#39;</span><span class="p">),</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_getN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">returntype</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">returntype</span> <span class="ow">is</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">_Nstring</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">returntype</span> <span class="o">=</span> <span class="s">&quot;xray&quot;</span>
            <span class="k">if</span> <span class="n">_Nstring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">):</span>
                <span class="c"># automagically do the right thing</span>
                <span class="n">returntype</span> <span class="o">=</span> <span class="s">&quot;psf&quot;</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_Nstring</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">elif</span> <span class="n">_Nstring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_Nstring</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s">&quot;psf&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wpsf</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s">&quot;xray&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wxray</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Wpsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resid_xray</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns resid in psf of crystallographic water W(resid_xray).&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xray2psf</span><span class="p">[</span><span class="n">resid_xray</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No residue number </span><span class="si">%(resid_xray)d</span><span class="s"> in x-ray structure.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">hop</span><span class="o">.</span><span class="n">MissingDataError</span><span class="p">(</span><span class="s">&quot;Add the xray -&gt; psf translation table with add_xray2psf() first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wformatter</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">,</span><span class="n">typechar</span><span class="o">=</span><span class="s">&#39;#&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Wxray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resid_psf</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the crystal structure resid of water resid_psf in the psf.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf2xray</span><span class="p">[</span><span class="n">resid_psf</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No residue number </span><span class="si">%(resid_psf)d</span><span class="s"> in psf.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">hop</span><span class="o">.</span><span class="n">MissingDataError</span><span class="p">(</span><span class="s">&quot;Add the psf -&gt; x-ray translation table with add_xray2psf() first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Wformatter</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">,</span><span class="n">typechar</span><span class="o">=</span><span class="s">&#39;W&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Wformatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resid</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">typechar</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># no error checks, only call from wrappers</span>
        <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">typechar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">default_format</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">typechar</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="si">%(resid)d</span><span class="s">&#39;</span>
            <span class="k">return</span>  <span class="n">default_format</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;%(resid)&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resid</span>

<div class="viewcode-block" id="PDBDensity.equivalence_sites"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity.equivalence_sites">[docs]</a>    <span class="k">def</span> <span class="nf">equivalence_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All equivalence sites (if defined) together with crystallographic water labels.</span>

<span class="sd">        recarray &lt;-- equivalence_sites(self,format=True)</span>

<span class="sd">        The numpy.recarray has columns</span>
<span class="sd">            equivalence_label        the integer label of the equivalence site</span>
<span class="sd">            equivalence_name         the name, a string</span>
<span class="sd">            xray                     the identifier of the X-ray water</span>

<span class="sd">        equivalence_label and equivalence_name are identical between the densities from</span>
<span class="sd">        which the equivalence sites were computed. The xray identifier is specific for the</span>
<span class="sd">        structure; by default it is a string such as &#39;W135&#39;.</span>

<span class="sd">        format        True: print &#39;W&lt;N&gt;&#39; identifier</span>
<span class="sd">                      False: integer &lt;N&gt;</span>
<span class="sd">                      (see W() for more possibilities)</span>

<span class="sd">        BUG: THIS IS NOT WORKING AS THOUGHT BECAUSE THERE IS NO 1-1</span>
<span class="sd">        MAPPING BETWEEN WATER MOLECULES AND SITES AND BECAUSE SITES</span>
<span class="sd">        ARE NOT NUMBERED IN THE SAME ORDER AS THE WATER MOLECULES</span>
<span class="sd">        </span>
<span class="sd">        TODO: The proper way to do this is to find all water molecules</span>
<span class="sd">        within a cutoff of each grid cell that belongs to a site and</span>
<span class="sd">        then store all the waters as the string name of the site.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">equiv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsites_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">equivlabel</span><span class="p">,</span><span class="n">subsites</span> <span class="ow">in</span> <span class="n">equiv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">equivlabel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivlabel2equivname</span><span class="p">(</span><span class="n">equivlabel</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site2resid</span><span class="p">(</span><span class="n">subsites</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">returntype</span><span class="o">=</span><span class="s">&#39;xray&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">records</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="s">&quot;equivalence_label,equivalence_name,xray&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PDBDensity.site2resid"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.PDBDensity.site2resid">[docs]</a>    <span class="k">def</span> <span class="nf">site2resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sitelabel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the resid of the particle that provided the density  for the site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;site2resid mapping is not working yet&#39;</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="print_combined_equivalence_sites"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.print_combined_equivalence_sites">[docs]</a><span class="k">def</span> <span class="nf">print_combined_equivalence_sites</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">reference</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tabulate equivalence sites of target against the reference.</span>

<span class="sd">    BUG: THIS IS NOT WORKING (because the assignment sites &lt;--&gt; waters</span>
<span class="sd">    is broken)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eqs_r</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">equivalence_sites</span><span class="p">()</span>
    <span class="n">eqs_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">equivalence_sites</span><span class="p">()</span>
    <span class="n">eqs_r</span><span class="o">.</span><span class="n">equivalence_name</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">sorted_t</span> <span class="o">=</span> <span class="n">eqs_t</span><span class="p">[</span><span class="n">eqs_t</span><span class="o">.</span><span class="n">equivalence_label</span> <span class="o">==</span> <span class="n">eqs_r</span><span class="o">.</span><span class="n">equivalence_label</span><span class="p">]</span>
    <span class="n">_header</span> <span class="o">=</span>  <span class="s">&quot;</span><span class="si">%3s</span><span class="s"> </span><span class="si">%4s</span><span class="s">   </span><span class="si">%-5s</span><span class="s"> </span><span class="si">%-6s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;ref&#39;</span><span class="p">,</span> <span class="s">&#39;target&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">___</span><span class="p">():</span> <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_header</span><span class="p">)</span>
    <span class="n">___</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">_header</span>
    <span class="n">___</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">x1</span><span class="p">),(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eqs_r</span><span class="p">,</span><span class="n">sorted_t</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="si">%3d</span><span class="s"> </span><span class="si">%4s</span><span class="s">   </span><span class="si">%-5s</span><span class="s">  </span><span class="si">%-5s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">___</span><span class="p">()</span>        

</div>
<div class="viewcode-block" id="BfactorDensityCreator"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.BfactorDensityCreator">[docs]</a><span class="k">class</span> <span class="nc">BfactorDensityCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density grid from a pdb file using MDAnalysis.</span>

<span class="sd">      dens = BfactorDensityCreator(psf,pdb,...).PDBDensity()</span>

<span class="sd">    The main purpose of this function is to convert crystal waters in</span>
<span class="sd">    an X-ray structure into a density so that one can compare the</span>
<span class="sd">    experimental density with the one from molecular dynamics</span>
<span class="sd">    trajectories. Because a pdb is a single snapshot, the density is</span>
<span class="sd">    estimated by placing Gaussians of width sigma at the position of</span>
<span class="sd">    all selected atoms.</span>
<span class="sd">    </span>
<span class="sd">    Sigma can be fixed or taken from the B-factor field, in which case</span>
<span class="sd">    sigma is taken as sqrt(3.*B/8.)/pi.</span>

<span class="sd">    TODO: </span>
<span class="sd">  </span>
<span class="sd">    * Make Gaussian convolution more efficient (at least for same</span>
<span class="sd">      sigma) because right now it is VERY slow (which may be</span>
<span class="sd">      acceptable if one only runs this once)</span>
<span class="sd">    * Using a temporary Creator class with the PDBDensity() helper</span>
<span class="sd">      method is clumsy (but was chosen as to keep the PDBDensity class</span>
<span class="sd">      clean and __init__ compatible with Density).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span><span class="n">pdb</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">atomselection</span><span class="o">=</span><span class="s">&#39;name OH2&#39;</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">padding</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the density from psf and pdb and the atomselection.</span>

<span class="sd">        DC = BfactorDensityCreator(psf, pdb, delta=&lt;delta&gt;, atomselection=&lt;MDAnalysis selection&gt;,</span>
<span class="sd">                                  metadata=&lt;dict&gt;, padding=2, sigma=None)</span>
<span class="sd">        density = DC.PDBDensity()                        </span>

<span class="sd">        psf     Charmm psf topology file</span>
<span class="sd">        pdb     PDB file</span>
<span class="sd">        atomselection</span>
<span class="sd">                selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">        delta   approximate bin size for the density grid (same in x,y,z)</span>
<span class="sd">                (It is slightly adjusted when the box length is not an integer multiple</span>
<span class="sd">                of delta.)</span>
<span class="sd">        metadata</span>
<span class="sd">                dictionary of additional data to be saved with the object</span>
<span class="sd">        padding increase histogram dimensions by padding (on top of initial box size)</span>
<span class="sd">        sigma   width (in Angstrom) of the gaussians that are used to build up the</span>
<span class="sd">                density; if None then uses B-factors from pdb</span>
<span class="sd">        verbosity=int  level of chattiness; 0 is silent, 3 is verbose</span>

<span class="sd">        For assigning X-ray waters to MD densities one might have to use a sigma</span>
<span class="sd">        of about 0.5 A to obtain a well-defined and resolved x-ray water density</span>
<span class="sd">        that can be easily matched to a broader density distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
        <span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>  <span class="c"># set to 0 for no messages</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">psf</span><span class="p">,</span><span class="n">pdbfilename</span><span class="o">=</span><span class="n">pdb</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Selected </span><span class="si">%d</span><span class="s"> atoms (</span><span class="si">%s</span><span class="s">) out of </span><span class="si">%d</span><span class="s"> total.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">atomselection</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
        <span class="n">smin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span>

        <span class="n">BINS</span> <span class="o">=</span> <span class="n">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>    
        <span class="n">arange</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">BINS</span><span class="p">[</span><span class="s">&#39;min&#39;</span><span class="p">],</span><span class="n">BINS</span><span class="p">[</span><span class="s">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">BINS</span><span class="p">[</span><span class="s">&#39;Nbins&#39;</span><span class="p">]</span>
        
        <span class="c"># get edges by doing a fake run</span>
        <span class="n">grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> 
                                            <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span><span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># histogram individually, and smear out at the same time</span>
            <span class="c"># with the appropriate B-factor</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">bfactors</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Some B-factors are Zero.&quot;</span><span class="p">,</span><span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">rmsf</span> <span class="o">=</span> <span class="n">Bfactor2RMSF</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">bfactors</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">*=</span> <span class="mf">0.0</span>  <span class="c"># reset grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smear_rmsf</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span><span class="n">rmsf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># histogram &#39;delta functions&#39;</span>
            <span class="n">grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span><span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Histogrammed </span><span class="si">%6d</span><span class="s"> atoms from pdb.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
            <span class="c"># just a convolution of the density with a Gaussian</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smear_sigma</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;psf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">psf</span><span class="o">=</span><span class="n">psf</span><span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;pdb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdb</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;atomselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomselection</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;n_frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_frames</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>

        <span class="c"># Density automatically converts histogram to density for isDensity=False</span>
        <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Histogram completed (density in Angstrom**-3)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BfactorDensityCreator.PDBDensity"><a class="viewcode-back" href="../../hop/sitemap.html#hop.sitemap.BfactorDensityCreator.PDBDensity">[docs]</a>    <span class="k">def</span> <span class="nf">PDBDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a PDBDensity object.</span>

<span class="sd">        The PDBDensity is a Density with a xray2psf translation table;</span>
<span class="sd">        it has also got an empty bulk site inserted (so that any</span>
<span class="sd">        further analysis which assumes that site number 1 is the bulk)</span>
<span class="sd">        does not discard a valid site.</span>

<span class="sd">        threshold      Use the given threshold to generate the graph; the threshold</span>
<span class="sd">                       is assumed to be in the same units as the density.</span>
<span class="sd">                       None: choose defaults (1.0 if bfactors were used, 1.3 otherwise)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">PDBDensity</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="s">&#39;Angstrom&#39;</span><span class="p">),</span>
                       <span class="n">parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">isDensity</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span><span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">add_xray2psf</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;pdb&#39;</span><span class="p">])</span>     <span class="c"># pdb filename is recorded in metadata</span>
        <span class="n">d</span><span class="o">.</span><span class="n">convert_density</span><span class="p">(</span><span class="s">&#39;water&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="mf">1.3</span>
        <span class="n">d</span><span class="o">.</span><span class="n">map_sites</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">site_insert_nobulk</span><span class="p">()</span>   <span class="c"># fake bulk site</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">_check_site_resid_match</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;There are different numbers of water molecules (</span><span class="si">%d</span><span class="s">) and sites (</span><span class="si">%d</span><span class="s">). &quot;</span>
                          <span class="s">&quot;Site &lt;-&gt; water matching will not work.&quot;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_xray2psf</span><span class="p">),</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">site_labels</span><span class="p">(</span><span class="s">&#39;sites&#39;</span><span class="p">,</span><span class="n">exclude</span><span class="o">=</span><span class="s">&#39;equivalencesites&#39;</span><span class="p">))),</span>
                          <span class="n">category</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">InconsistentDataWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">_smear_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">sigma</span><span class="p">):</span>
        <span class="c"># smear out points</span>
        <span class="c"># (not optimized -- just to test the principle; faster approach could use</span>
        <span class="c"># convolution of the whole density with a single Gaussian via FFTs:</span>
        <span class="c"># rho_smeared = F^-1[ F[g]*F[rho] ]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>   <span class="c"># holds the smeared out density</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># position in histogram (as bin numbers)</span>
        <span class="k">for</span> <span class="n">iwat</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span> <span class="c"># super-ugly loop</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">wp</span><span class="p">[</span><span class="n">iwat</span><span class="p">]</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">*</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussian</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
                                   <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Smearing out water position </span><span class="si">%4d</span><span class="s">/</span><span class="si">%5d</span><span class="s"> with RMSF </span><span class="si">%4.2f</span><span class="s"> A</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">%</span>  \
                    <span class="p">(</span><span class="n">iwat</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">g</span>
        
    <span class="k">def</span> <span class="nf">_smear_rmsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coordinates</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">rmsf</span><span class="p">):</span>
        <span class="c"># smear out each water with its individual Gaussian</span>
        <span class="c"># (slower than smear_sigma)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>   <span class="c"># holds the smeared out density</span>
        <span class="n">N</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">iwat</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_cartesian</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
                                    <span class="n">c</span><span class="o">=</span><span class="n">coord</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="n">rmsf</span><span class="p">[</span><span class="n">iwat</span><span class="p">])</span>
            <span class="n">msg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;Smearing out water position </span><span class="si">%4d</span><span class="s">/</span><span class="si">%5d</span><span class="s"> with RMSF </span><span class="si">%4.2f</span><span class="s"> A</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">%</span>  \
                    <span class="p">(</span><span class="n">iwat</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">rmsf</span><span class="p">[</span><span class="n">iwat</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">g</span>


    <span class="k">def</span> <span class="nf">_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">sigma</span><span class="p">):</span>
        <span class="c"># i,j,k can be numpy arrays</span>
        <span class="c"># p is center of gaussian as grid index, sigma its width (in A)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># in Angstrom</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>            
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_gaussian_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">sigma</span><span class="p">):</span>
        <span class="c"># i,j,k can be numpy arrays</span>
        <span class="c"># c is center of gaussian in cartesian coord (A), sigma its width (in A)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">i</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># in Angstrom</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">j</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Hop 0.3.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Thomas B. Woolf, Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>